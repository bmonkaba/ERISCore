<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ERIS CORE: modularity</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ERIS CORE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d7/d45/md__e_r_i_s_core_lib_wren_doc_site_modularity.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">modularity </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>^title Modularity</p>
<p>Once you start writing programs that are more than little toys, you quickly run into two problems:</p>
<ol type="1">
<li>You want to break them down into multiple smaller files to make it easier to find your way around them.</li>
<li>You want to reuse pieces of them across different programs.</li>
</ol>
<p>To address those, Wren has a simple module system. A file containing Wren code defines a <em>module</em>. A module can use the code defined in another module by <em>importing</em> it. You can break big programs into smaller modules that you import, and you can reuse code by having multiple programs share the use of a single module.</p>
<p>Wren does not have a single global scope. Instead, each module has its own top-level scope independent of all other modules. This means, for example, that two modules can define a top-level variable with the same name without causing a name collision. Each module is, well, modular.</p>
<h2><a class="anchor" id="autotoc_md292"></a>
Importing, briefly</h2>
<p>When you run Wren and give it a file name to execute, the contents of that file define the "main" module that execution starts at. To load and execute other modules, you use an import statement:</p>
<pre class="snippet">
import "beverages" for Coffee, Tea
</pre><p>This finds a module named "beverages" and executes its source code. Then, it looks up two top-level variables, <code>Coffee</code> and <code>Tea</code> in <em>that</em> module and creates new variables in <em>this</em> module with their values.</p>
<p>This statement can appear anywhere a variable declaration is allowed, even inside blocks:</p>
<pre class="snippet">
if (thirsty) {
  import "beverages" for Coffee, Tea
}
</pre><p>If you need to import a variable under a different name, you can use <code>import "..." for Name as OtherName</code>. This looks up the top-level variable <code>Name</code> in <em>that</em> module, but declares a variable called <code>OtherName</code> in <em>this</em> module with its value.</p>
<pre class="snippet">
import "liquids" for Water //Water is now taken
import "beverages" for Coffee, Water as H2O, Tea
// var water = H2O.new()
</pre><p>If you want to load a module, but not bind any variables from it, you can omit the <code>for</code> clause:</p>
<pre class="snippet">
import "some_imperative_code"
</pre><p>That's the basic idea. Now let's break it down into each of the steps it performs:</p>
<ol type="1">
<li>Locate the source code for the module.</li>
<li>Execute the imported module's code.</li>
<li>Bind new variables in the importing module to values defined in the imported module.</li>
</ol>
<p>We'll go through each step:</p>
<h2><a class="anchor" id="autotoc_md293"></a>
Locating a module</h2>
<p>The first thing you need to do to import a module is actually <em>find</em> the code for it. The import specifies a <em>name</em>&mdash;some arbitrary string that is used to uniquely identify the module. The embedding application controls how that string is used to locate a blob of source code.</p>
<p>When the host application creates a new Wren VM, it provides a module loader function:</p>
<pre class="snippet" data-lang="c">
<a class="el" href="../../d5/df9/struct_wren_configuration.html">WrenConfiguration</a> config;
config.loadModuleFn = loadModule;

// Other configuration...

WrenVM* vm = wrenNewVM(&amp;config);
</pre><p>That function has this signature:</p>
<pre class="snippet" data-lang="c">
<a class="el" href="../../d2/d9b/struct_wren_load_module_result.html">WrenLoadModuleResult</a> <a class="el" href="../../dd/d19/wren_8h.html#a2fc3ae35e8b24fc01fca4ea0a2c31cf5">WrenLoadModuleFn(WrenVM* vm, const char* name)</a>;
</pre><p>Whenever a module is imported, the VM calls this and passes it the name of the module. The embedder is expected to return the source code contents of the module in a <code><a class="el" href="../../d2/d9b/struct_wren_load_module_result.html">WrenLoadModuleResult</a></code>. When you embed Wren in your app, you can handle this however you want: reach out to the file system, look inside resources bundled into your app, whatever.</p>
<p>You can return the source field as <code>NULL</code> from this function to indicate that a module couldn't be found. When you do this, Wren will report it as a runtime error.</p>
<h3><a class="anchor" id="autotoc_md294"></a>
The command-line loader</h3>
<p>The <a href="../../getting-started.html#using-the-wren-cli">Wren CLI command-line tool</a> has a very simple lookup process. It appends the module name and ".wren" to the directory where the main module was loaded and looks for that file. So, let's say you run: </p><pre class="fragment">$ wren code/my_program.wren
</pre><p> And that main module has:</p>
<pre class="snippet">
import "some/module"
</pre><p>Then the command-line VM will try to find <code>/code/some/module.wren</code>. By convention, forward slashes should be used as path separators, even on Windows, to help ensure your scripts are platform-independent. (Forward slashes are a valid separator on Windows, but backslashes are not valid on other OSes.)</p>
<h2><a class="anchor" id="autotoc_md295"></a>
Executing the module</h2>
<p>Once we have the source code for a module, we need to run it. First, the VM takes the <a href="../../concurrency.html">fiber</a> that is executing the <code>import</code> statement in the importing module and pauses it.</p>
<p>Then it creates a new module object&mdash;a new fresh top-level scope, basically&mdash;and a new fiber. It executes the new module's code in that fiber and scope. The module can run whatever imperative code it wants and define whatever top-level variables it wants.</p>
<p>When the module's code is done being executed and its fiber completes, the suspended fiber for the importing module is resumed. This suspending and resuming is recursive. So, if "a" imports "b" which imports "c", both "a" and "b" will be suspended while "c" is running. When "c" is done, "b" is resumed. Then, when "b" completes, "a" is resumed.</p>
<p>Think of it like traversing the tree of imports, one node at a time. At any given point in time, only one module's code is running.</p>
<h2><a class="anchor" id="autotoc_md296"></a>
Binding variables</h2>
<p>Once the module is done executing, the last step is to actually <em>import</em> some data from it. Any module can define "top-level" <a href="../../variables.html">variables</a>. These are simply variables declared outside of any <a href="../../classes.html#methods">method</a> or <a href="../../functions.html">function</a>.</p>
<p>These are visible to anything inside the module, but they can also be <em>exported</em> and used by other modules. When Wren executes an import like:</p>
<pre class="snippet">
import "beverages" for Coffee, Tea
</pre><p>First it runs the "beverages" module. Then it goes through each of the variable names in the <code>for</code> clause. For each one, it looks for a top-level variable with that name in the imported module. If a variable with that name can't be found in the imported module, it's a runtime error.</p>
<p>Otherwise, it gets the current value of the variable and defines a new variable in the importing module with the same name and value. It's worth noting that the importing module gets its <em>own</em> variable whose value is a snapshot of the value of the imported variable at the time it was imported. If either module later assigns to that variable, the other won't see it. It's not a "live" connection.</p>
<p>In practice, most top-level variables are only assigned once anyway, so this rarely makes a difference.</p>
<h2><a class="anchor" id="autotoc_md297"></a>
Shared imports</h2>
<p>Earlier, I described a program's set of modules as a tree. Of course, it's only a <em>tree</em> of modules if there are no <em>shared imports</em>. But consider a program like:</p>
<pre class="snippet">
// main.wren
import "a"
import "b"

// a.wren
import "shared"

// b.wren
import "shared"

// shared.wren
System.print("Shared!")
</pre><p>Here, "a" and "b" both want to use "shared". If "shared" defines some top-level state, we only want a single copy of that in memory. To handle this, a module's code is only executed the <em>first</em> time it is loaded. After that, importing the module again just looks up the previously loaded module.</p>
<p>Internally, Wren maintains a map of every module it has previously loaded. When a module is imported, Wren looks for it in that map first before it calls out to the embedder for its source.</p>
<p>In other words, in that list of steps above, there's an implicit zeroth step: "See if we already loaded the module and reuse it if we did". That means the above program only prints "Shared!" once.</p>
<h2><a class="anchor" id="autotoc_md298"></a>
Cyclic imports</h2>
<p>You can even have cycles in your imports, provided you're a bit careful with them. The loading process, in detail, is:</p>
<ol type="1">
<li>See if we have already created a module with the given name.</li>
<li>If so, use it.</li>
<li>Otherwise, create a new module with the name and store it in the module registry.</li>
<li>Create a fiber for it and execute its code.</li>
</ol>
<p>Note the order of the last two steps. When a module is loaded, it is added to the registry <em>before</em> it is executed. This means if an import for that same module is reached while the module itself or one of its imports is executing, it will be found in the registry and the cycle is short-circuited.</p>
<p>For example:</p>
<pre class="snippet">
// main.wren
import "a"

// a.wren
System.print("start a")
import "b"
System.print("end a")

// b.wren
System.print("start b")
import "a"
System.print("end b")
</pre><p>This program runs successfully and prints: </p><pre class="fragment">start a
start b
end b
end a
</pre><p> Where you have to be careful is binding variables. Consider:</p>
<pre class="snippet">
// main.wren
import "a"

// a.wren
import "b" for B
var A = "a variable"

// b.wren
import "a" for A
var B = "b variable"
</pre><p>The import of "a" in b.wren will fail here. If you trace the execution, you get:</p>
<ol type="1">
<li>Execute <code>import "a"</code> in "main.wren". That suspends "main.wren".</li>
<li>Execute <code>import "b"</code> in "a.wren". That suspends "a.wren".</li>
<li>Execute <code>import "a"</code> in "b.wren". Since "a" is already in the module map, this does <em>not</em> suspend it.</li>
</ol>
<p>Instead, we look for a variable named <code>A</code> in that module. But it hasn't been defined yet since "a.wren" is still sitting on the <code>import "b" for B</code> line before the declaration. To get this to work, you would need to move the variable declaration above the import:</p>
<pre class="snippet">
// main.wren
import "a"

// a.wren
var A = "a variable"
import "b" for B

// b.wren
import "a" for A
var B = "b variable"
</pre><p>Now when we run it, we get:</p>
<ol type="1">
<li>Execute <code>import "a"</code> in "main.wren". That suspends "main.wren".</li>
<li>Define <code>A</code> in "a.wren".</li>
</ol>
<ol type="1">
<li>Execute <code>import "b"</code> in "a.wren". That suspends "a.wren".</li>
<li>Execute <code>import "a"</code> in "b.wren". Since "a" is already in the module map, this does <em>not</em> suspend it. It looks up <code>A</code>, which has already been defined, and binds it.</li>
<li>Define <code>B</code> in "b.wren".</li>
<li>Complete "b.wren".</li>
<li>Look up <code>B</code> in "b.wren" and bind it in "a.wren".</li>
<li>Resume "a.wren".</li>
</ol>
<p>This sounds super hairy, but that's because cyclic dependencies are hairy in general. The key point here is that Wren <em>can</em> handle them in the rare cases where you need them.</p>
<h2><a class="anchor" id="autotoc_md299"></a>
Exiting a module early</h2>
<p>Although the <code>return</code> statement is normally used to exit from a <a href="../../classes.html#methods">method</a> or a <a href="../../functions.html">function</a>, it can also be used from a module's top-level code to exit the module. For example, if the script consists of a single module, this code would exit the module (and therefore the script) early:</p>
<pre class="snippet">
for (i in 1..2) {
  if (i == 2) return
  System.print(i)  //&gt;  prints 1 but not 2
}
System.print(3)    //&gt;  not reached
</pre><p>Although it is not invalid to return a value, there is no way to access that value and it is therefore simply discarded.</p>
<p><br  />
</p><hr  />
<p> <a href="../../error-handling.html">&larr; Error Handling</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
