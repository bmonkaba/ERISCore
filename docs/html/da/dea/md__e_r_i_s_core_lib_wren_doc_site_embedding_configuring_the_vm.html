<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ERIS CORE: configuring-the-vm</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ERIS CORE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('da/dea/md__e_r_i_s_core_lib_wren_doc_site_embedding_configuring_the_vm.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">configuring-the-vm </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>^title Configuring the VM</p>
<p>When you create a Wren VM, you tweak it by passing in a pointer to a <a class="el" href="../../d5/df9/struct_wren_configuration.html">WrenConfiguration</a> structure. Since Wren has no global state, you can configure each VM differently if your application happens to run multiple.</p>
<p>The struct looks like:</p>
<pre class="snippet" data-lang="c">
typedef struct
{
  WrenReallocateFn reallocateFn;
  WrenLoadModuleFn loadModuleFn;
  WrenBindForeignMethodFn bindForeignMethodFn;
  WrenBindForeignClassFn bindForeignClassFn;
  WrenWriteFn writeFn;
  WrenErrorFn errorFn;
  size_t initialHeapSize;
  size_t minHeapSize;
  int heapGrowthPercent;
} <a class="el" href="../../d5/df9/struct_wren_configuration.html">WrenConfiguration</a>;
</pre><p>Most fields have useful defaults, which you can (and should) initialize by calling:</p>
<pre class="snippet" data-lang="c">
wrenInitConfiguration(&amp;configuration);
</pre><p>Calling this ensures that your VM doesn't get uninitialized configuration when new fields are added to <a class="el" href="../../d5/df9/struct_wren_configuration.html">WrenConfiguration</a>. Here is what each field does, roughly categorized:</p>
<h2><a class="anchor" id="autotoc_md179"></a>
Binding</h2>
<p>The VM is isolated from the outside world. These callbacks let the VM request access to imported code and foreign functionality.</p>
<h3><a class="anchor" id="autotoc_md180"></a>
**&lt;tt&gt;loadModuleFn&lt;/tt&gt;**</h3>
<p>This is the callback Wren uses to load an imported module. The VM itself does not know how to talk to the file system, so when an <code>import</code> statement is executed, it relies on the host application to locate and read the source code for a module.</p>
<p>The signature of this function is:</p>
<pre class="snippet" data-lang="c">
<a class="el" href="../../d2/d9b/struct_wren_load_module_result.html">WrenLoadModuleResult</a> loadModule(WrenVM* vm, const char* name)
</pre><p>When a module is imported, Wren calls this and passes in the module's name. The host should return the source code for that module in a <code><a class="el" href="../../d2/d9b/struct_wren_load_module_result.html">WrenLoadModuleResult</a></code> struct.</p>
<pre class="snippet" data-lang="c">
<a class="el" href="../../d2/d9b/struct_wren_load_module_result.html">WrenLoadModuleResult</a> myLoadModule(WrenVM* vm, const char* name) {
  <a class="el" href="../../d2/d9b/struct_wren_load_module_result.html">WrenLoadModuleResult</a> result = {0};
    result.source = getSourceForModule(name);
  return result;
}
</pre><p>The module loader is only be called once for any given module name. Wren caches the result internally so subsequent imports of the same module use the previously loaded code.</p>
<p>If your host application isn't able to load a module with some name, it should make sure the <code>source</code> value is <code>NULL</code> when returned. Wren will then report that as a runtime error.</p>
<p>If you don't use any <code>import</code> statements, you can leave the <code>loadModuleFn</code> field in the configuration set to <code>NULL</code> (the default).</p>
<p>Additionally, the <code><a class="el" href="../../d2/d9b/struct_wren_load_module_result.html">WrenLoadModuleResult</a></code> allows us to add a callback for when Wren is done with the <code>source</code>, so we can free the memory if needed.</p>
<pre class="snippet" data-lang="c">

static void loadModuleComplete(WrenVM* vm, 
                               const char* module,
                               <a class="el" href="../../d2/d9b/struct_wren_load_module_result.html">WrenLoadModuleResult</a> result) 
{
  if(result.source) {
    //for example, if we used malloc to allocate
    //our source string, we use free to release it.
    free((void*)result.source);
  }
}

<a class="el" href="../../d2/d9b/struct_wren_load_module_result.html">WrenLoadModuleResult</a> myLoadModule(WrenVM* vm, const char* name) {
  <a class="el" href="../../d2/d9b/struct_wren_load_module_result.html">WrenLoadModuleResult</a> result = {0};
    result.onComplete = loadModuleComplete;
    result.source = getSourceForModule(name);
  return result;
}
</pre><h3><a class="anchor" id="autotoc_md181"></a>
**&lt;tt&gt;bindForeignMethodFn&lt;/tt&gt;**</h3>
<p>The callback Wren uses to find a foreign method and bind it to a class. See <a href="../..//embedding/calling-c-from-wren.html">this page</a> for details. If your application defines no foreign methods, you can leave this <code>NULL</code>.</p>
<h3><a class="anchor" id="autotoc_md182"></a>
**&lt;tt&gt;bindForeignClassFn&lt;/tt&gt;**</h3>
<p>The callback Wren uses to find a foreign class and get its foreign methods. See <a href="../..//embedding/storing-c-data.html">this page</a> for details. If your application defines no foreign classes, you can leave this <code>NULL</code>.</p>
<h2><a class="anchor" id="autotoc_md183"></a>
Diagnostics</h2>
<p>These let you wire up some minimal output so you can tell if your code is doing what you expect.</p>
<h3><a class="anchor" id="autotoc_md184"></a>
**&lt;tt&gt;writeFn&lt;/tt&gt;**</h3>
<p>This is the callback Wren uses to output text when <code>System.print()</code> or the other related functions are called. This is the minimal connection the VM has with the outside world and lets you do rudimentary "printf debugging". Its signature is:</p>
<pre class="snippet" data-lang="c">
void write(WrenVM* vm, const char* text)
</pre><p>Wren does <em>not</em> have a default implementation for this. It's up to you to wire it up to <code>printf()</code> or some other way to show the text. If you leave it <code>NULL</code>, calls to <code>System.print()</code> and others silently do nothing.</p>
<h3><a class="anchor" id="autotoc_md185"></a>
**&lt;tt&gt;errorFn&lt;/tt&gt;**</h3>
<p>Wren uses this callback to report compile time and runtime errors. Its signature is:</p>
<pre class="snippet" data-lang="c">
void error(
      WrenVM* vm, 
      WrenErrorType type,
      const char* module,
      int line,
      const char* message)
</pre><p>The <code>type</code> parameter is one of:</p>
<pre class="snippet" data-lang="c">
typedef enum
{
  // A syntax or resolution error detected at compile time.
  WREN_ERROR_COMPILE,

  // The error message for a runtime error.
  WREN_ERROR_RUNTIME,

  // One entry of a runtime error's stack trace.
  WREN_ERROR_STACK_TRACE
} WrenErrorType;
</pre><p>When a compile error occurs, <code>errorFn</code> is called once with type <code>WREN_ERROR_COMPILE</code>, the name of the module and line where the error occurs, and the error message.</p>
<p>Runtime errors include stack traces. To handle this, Wren first calls <code>errorFn</code> with <code>WREN_ERROR_RUNTIME</code>, no module or line, and the runtime error's message. After that, it calls <code>errorFn</code> again using type <code>WREN_ERROR_STACK_TRACE</code>, once for each line in the stack trace. Each of those calls has the module and line where the method or function is defined and <code>message</code> is the name of the method or function.</p>
<p>If you leave this <code>NULL</code>, Wren does not report any errors.</p>
<h2><a class="anchor" id="autotoc_md186"></a>
Memory Management</h2>
<p>These fields control how the VM allocates and manages memory.</p>
<h3><a class="anchor" id="autotoc_md187"></a>
**&lt;tt&gt;reallocateFn&lt;/tt&gt;**</h3>
<p>This lets you provide a custom memory allocation function. Its signature is:</p>
<pre class="snippet" data-lang="c">
void* reallocate(void* memory, size_t newSize, void* userData)
</pre><p>Wren uses this one function to allocate, grow, shrink, and deallocate memory. When called, <code>memory</code> is the existing pointer to the block of memory if an allocation is being changed or freed. If Wren is requesting new memory, then <code>memory</code> is <code>NULL</code>.</p>
<p><code>newSize</code> is the number of bytes of memory being requested. If memory is being freed, this is zero. Your callback should allocate the proper amount of memory and return it.</p>
<p>If you don't provide a custom allocator, the VM uses a default one that relies on <code>realloc</code> and <code>free</code>.</p>
<h3><a class="anchor" id="autotoc_md188"></a>
**&lt;tt&gt;initialHeapSize&lt;/tt&gt;**</h3>
<p>This defines the total number of bytes of memory the VM will allocate before triggering the first garbage collection. Setting this to a smaller number reduces the amount of memory Wren will have allocated at one time, but causes it to collect garbage more frequently.</p>
<p>If you set this to zero, Wren uses a default size of 10MB.</p>
<h3><a class="anchor" id="autotoc_md189"></a>
**&lt;tt&gt;minHeapSize&lt;/tt&gt;**</h3>
<p>After a garbage collection occurs, the threshold for the <em>next</em> collection is determined based on the number of bytes remaining in use. This allows Wren to grow or shrink its memory usage automatically based on how much memory is actually needed.</p>
<p>This can be used to ensure that the heap does not get <em>too</em> small, which can in turn lead to a large number of collections afterwards as the heap grows back to a usable size.</p>
<p>If zero, this defaults to 1MB.</p>
<h3><a class="anchor" id="autotoc_md190"></a>
**&lt;tt&gt;heapGrowthPercent&lt;/tt&gt;**</h3>
<p>Wren tunes the rate of garbage collection based on how much memory is still in use after a collection. This number controls that. It determines the amount of additional memory Wren will use after a collection, as a percentage of the current heap size.</p>
<p>For example, say that this is 50. After a garbage collection, there are 400 bytes of memory still in use. That means the next collection will be triggered after a total of 600 bytes are allocated (including the 400 already in use.)</p>
<p>Setting this to a smaller number wastes less memory, but triggers more frequent garbage collections.</p>
<p>If set to zero, the VM uses a default of 50.</p>
<p><a href="../../storing-c-data.html">&larr; Storing C Data</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
