<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ERIS CORE: Smarter Imports</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ERIS CORE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d9/d1e/md__e_r_i_s_core_lib_wren_doc_rfc_0001_smarter_imports.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Smarter Imports </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Note: This is now mostly implemented, though the implementation differs somewhat from this original proposal.</b></p>
<p>Here's a proposal for improving how imported modules are identified and found to hopefully help us start growing an ecosystem of reusable Wren code. Please do <a href="https://groups.google.com/forum/#!forum/wren-lang">let me know</a> what you think!</p>
<h1><a class="anchor" id="autotoc_md65"></a>
Motivation</h1>
<p>As <a href="https://github.com/wren-lang/wren/issues/210">others</a> <a href="https://github.com/wren-lang/wren/issues/325">have</a> <a href="https://github.com/wren-lang/wren/issues/346">noted</a>, the way imports work in Wren, particularly how the CLI resolves them, makes it much too hard to reuse code. This proposal aims to improve that. It doesn't intend to fix <em>everything</em> about imports and the module system, but should leave the door open for later improvements.</p>
<h2><a class="anchor" id="autotoc_md66"></a>
Relative imports</h2>
<p>Today, it's hard to reuse your own code unless you literally dump everything in a single directory. Say you have:</p>
<div class="fragment"><div class="line">script_a.wren</div>
<div class="line">useful_stuff/</div>
<div class="line">  script_b.wren</div>
<div class="line">  thing_1.wren</div>
<div class="line">  thing_2.wren</div>
</div><!-- fragment --><p><code>script_a.wren</code> and <code>script_b.wren</code> are both scripts you can run directly from the CLI. They would both like to use <code>thing_1.wren</code>, which in turn imports <code>thing_2.wren</code>. What does <code>thing_1.wren</code> look like? If you do:</p>
<div class="fragment"><div class="line">// thing_1.wren</div>
<div class="line">import &quot;thing_2&quot;</div>
</div><!-- fragment --><p>Then it works fine if you run <code>script_b.wren</code> from the <code>useful_stuff/</code> directory. But if you try to run <code>script_a.wren</code> from the top level directory, then it looks for <code>thing_2.wren</code> <em>there</em> and fails to find it. If you change the import to:</p>
<div class="fragment"><div class="line">// thing_1.wren</div>
<div class="line">import &quot;useful_stuff/thing_2&quot;</div>
</div><!-- fragment --><p>Then <code>script_a.wren</code> works, but now <code>script_b.wren</code> is broken. The problem is that all imports are treated as relative to the directory containing the <em>initial script</em> you run. That means you can't reuse modules from scripts that live in different directories.</p>
<p>In this example, if feels like imports should be treated as relative to the file that contains the import statement. Often you want to specify, "Here is
*where* this other module is, relative to where *I* am."</p>
<h2><a class="anchor" id="autotoc_md73"></a>
Logical imports</h2>
<p>If we make imports relative, is that enough? Should <em>all</em> imports be relative? I don't think so. First of all, some modules are not even on the file system. There is no relative path that will take you to "random" — it's built into the VM itself. Likewise, "io" is baked into the CLI.</p>
<p>Today, when you write:</p>
<div class="fragment"><div class="line">import &quot;io&quot;</div>
</div><!-- fragment --><p>You aren't saying <em>where</em> that module should be found, you're saying <em>what</em> module you want. Assuming we get a package manager at some point, these kinds of "logical" imports will be common. So I want these too.</p>
<p>If you look at other langauges' package managers, you'll find many times a single package offers a number of separate libraries you can use. So I also want to support logical imports that contain a path too — the import would say both <em>what</em> package to look in and <em>where</em> in that package to look.</p>
<h2><a class="anchor" id="autotoc_md78"></a>
Only logical imports?</h2>
<p>Given some kind of package-y import syntax, could we get rid of relative imports and use those for everything? You'd treat your own program like it was itself some kind of package and anything you wanted to import in it you'd import relative to your app's root directory.</p>
<p>The problem is that the "root directory" for your program's "package" isn't well-defined. We could say it's always the same directory as the script you're running, but that's probably too limiting. You may want to run scripts that live in subdirectories.</p>
<p>We could walk up the parent directories looking for some kind of "manifest" file that declares "the root of the package is here", but that seems like a lot of hassle if you just want to create a couple of text files and start getting some code running. So, for your own programs, I think it's nice to still support "pure" relative imports.</p>
<h2><a class="anchor" id="autotoc_md84"></a>
Ambiguity?</h2>
<p>OK, so we want both relative imports and logical imports. Can we use the same syntax for both? We could allow, say:</p>
<div class="fragment"><div class="line">import &quot;a/b&quot;</div>
</div><!-- fragment --><p>And the semantics would be:</p>
<ol type="1">
<li>Look for a module "a/b.wren" relative to the file containing the import. If found, use it.</li>
<li>Otherwise, look inside some "package" directory for a package named "a" and a module named "b.wren" inside it. If found use that.</li>
<li>Otherwise, look for a built in module named "a".</li>
</ol>
<p>This is pretty much how things work now, but I don't think it's a good idea. Relative imports will tend to be short — often single words like "utils". Assuming we get a healthy package ecosystem at some point, the chances of one of those colliding with a logical import name are high.</p>
<p>Also, when reading code, I think it's important to be able to easily tell "this
import is from my own program" without having to know the names of all of the files and directories in the program.</p>
<h1><a class="anchor" id="autotoc_md87"></a>
Proposal</h1>
<p>OK, so here's my goals:</p>
<ol type="1">
<li>A way to import a module relative to the one containing the import.</li>
<li>A way to import a module from some named logical package, possibly at a specific path within that package.</li>
<li>Distinct syntaxes for each of these.</li>
</ol>
<p>I tried a few different ideas, and my favorite is:</p>
<h2><a class="anchor" id="autotoc_md88"></a>
Relative imports</h2>
<p>Relative imports use the existing syntax:</p>
<div class="fragment"><div class="line">// Relative path.</div>
<div class="line">import &quot;ast/expr&quot;</div>
</div><!-- fragment --><p>This looks for the file <code>ast/expr.wren</code> relative to the directory containing the module that has this import statement in it.</p>
<p>You can also walk out of directories if you need to import a module in a parent folder:</p>
<div class="fragment"><div class="line">import &quot;../../other/stuff&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md89"></a>
Logical imports</h2>
<p>If you want to import a module from some named logical entity, you use an <em>unquoted</em> identifier:</p>
<div class="fragment"><div class="line">import random</div>
</div><!-- fragment --><p>Being unquoted means the names must be valid Wren identifiers and can't be reserved words. I think that's OK. It would confuse the hell out of people if you had a library named "if". I think the above <em>looks</em> nice, and the fact that it's not quoted sends a signal (to me at least) that the name is a "what" more than a "where".</p>
<p>If you want to import a specific module within a logical entity, you can have a series of slash-separate identifiers after the name:</p>
<div class="fragment"><div class="line">import wrenalyzer/ast/expr</div>
</div><!-- fragment --><p>This imports module "ast/expr" from "wrenalyzer".</p>
<h1><a class="anchor" id="autotoc_md90"></a>
Implementation</h1>
<p>That's the proposed syntax and basic semantics. The way we actually implement it is tricky because Wren is both a standalone interpreter you can run on the command line and an embedded scripting language. We have to figure out what goes into the VM and what lives in the CLI, and the interface between the two.</p>
<h2><a class="anchor" id="autotoc_md91"></a>
VM</h2>
<p>As usual, I want to keep the VM minimal and free of policy. We do need to add support for the new unquoted syntax. The more significant change is to the API the VM uses to talk to the host app when a module is imported. The VM doesn't know how to actually load modules. When it executes an import statement, it calls:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span>* loadModuleFn(<a class="code" href="../../d7/ddb/struct_wren_v_m.html">WrenVM</a>* vm, <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="../../d0/de9/receiver-less_01calls_012_8txt.html#aebf44d721858a02d9b9deca9fff51b9e">name</a>);</div>
<div class="ttc" id="areceiver-less_01calls_012_8txt_html_aebf44d721858a02d9b9deca9fff51b9e"><div class="ttname"><a href="../../d0/de9/receiver-less_01calls_012_8txt.html#aebf44d721858a02d9b9deca9fff51b9e">name</a></div><div class="ttdeci">var how do we tell if it we see if there are any private getters that were not implemented and define implicit getters for them that return fields That s weird if you take into account though compile it to getter call Then see setter defined for so we no longer implicitly make a field But there s no so now the above call will fail Probably do want call to fail so that may be OK Given how do we tell if it which returns a field that s a and invoking it Since arity is part of the name</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/de9/receiver-less_01calls_012_8txt_source.html#l00051">receiver-less calls 2.txt:51</a></div></div>
<div class="ttc" id="astruct_wren_v_m_html"><div class="ttname"><a href="../../d7/ddb/struct_wren_v_m.html">WrenVM</a></div><div class="ttdef"><b>Definition:</b> <a href="../../d5/db1/wren__vm_8h_source.html#l00031">wren_vm.h:32</a></div></div>
</div><!-- fragment --><p>The VM tells the host app the import string and the host app returns the code. In order to distinguish relative imports (quoted) from an identical unquoted name and path, we need to pass in an extra to bit to tell the host whether there were quotes or not.</p>
<p>The more challenging change (and the reason I didn't support them when I first added imports to Wren) is relative imports. There are two tricky parts:</p>
<p>First, the host app doesn't have enough context to resolve a relative import. Right now, the VM only passes in the import string. It doesn't tell which module <em>contains</em> that import string, so the host has no way of knowing what that import should be relative <em>to</em>.</p>
<p>That's easy to fix. We have the VM pass in the name of the module that contains the import.</p>
<p>The harder problem is <b>canonicalization</b>. When you import the same module twice, the VM ensures it is only executed once and both places use the same module data. This is important to ensure you don't get confusing things like duplicate static state or other weird side effects.</p>
<p>To do that, the VM needs to be able to tell when two imports refer to the "same" module. Right now, it uses the import string itself. If two imports use the same string, they are the same module.</p>
<p>With relative imports, that is no longer valid. Consider:</p>
<div class="fragment"><div class="line">script_a.wren</div>
<div class="line">useful_stuff/</div>
<div class="line">  thing_1.wren</div>
<div class="line">  thing_2.wren</div>
</div><!-- fragment --><p>Now imagine those files contain:</p>
<div class="fragment"><div class="line">// script_a.wren</div>
<div class="line">import &quot;useful_stuff/thing_1&quot;</div>
<div class="line">import &quot;useful_stuff/thing_2&quot;</div>
<div class="line"> </div>
<div class="line">// useful_stuff/thing_1.wren</div>
<div class="line">import &quot;thing_2&quot;</div>
<div class="line"> </div>
<div class="line">// useful_stuff/thing_2.wren</div>
<div class="line">// Stuff...</div>
</div><!-- fragment --><p>Both <code>script_a.wren</code> and <code>thing_1</code> import <code>thing_2</code>, but the import <em>strings</em> are different. The VM needs to be able to figure out that those two imports refer to the same module. I don't want path manipulation logic in the VM, so it will delegate to the host app for that as well.</p>
<p>Given the import string and the name of the module containing it, the host app produces a "fully-qualified" or "canonical" name for the imported module. It is <em>that</em> resulting string that the VM uses to tell if two imports resolve to the same module. (It's also the string it uses in things like stack traces.)</p>
<p>This means importing becomes a three stage process:</p>
<ol type="1">
<li>First the VM asks the host to resolve an import. It gives it the (previously resolved) name of the module containing the import, the imports string, and whether or not it was quoted. The host app returns a canonical string for that import.</li>
<li>The VM checks to see if a module with that canonical name has already been imported. If so, it reuses that and its done.</li>
<li>Otherwise, it circles back and asks the host for the source of the module with that given canonical name. It compiles and executes that and goes from there.</li>
</ol>
<p>So we add a new callback to the embedding API. Something like:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span>* resolveModuleFn(<a class="code" href="../../d7/ddb/struct_wren_v_m.html">WrenVM</a>* vm,</div>
<div class="line">    <span class="comment">// Canonical name of the module containing the import.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* importer,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The import string.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* path,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Whether the path name was quoted.</span></div>
<div class="line">    <span class="keywordtype">bool</span> isQuoted);</div>
</div><!-- fragment --><p>The VM invokes this for step one above. The other two steps are the existing loading logic but now using the canonicalized string.</p>
<h2><a class="anchor" id="autotoc_md95"></a>
CLI</h2>
<p>All of the policy lives over in the CLI (or in your app if you are embedding the VM). You are free to use whatever canonicalization policy makes sense for you. For the CLI, and for the policy described up in motivation, it's something like this:</p>
<ul>
<li><p class="startli">Imports are slash-separated paths. Resolving a relative path is normal path joining relative to the directory containing the import. So if you're importing "a/b" from "c/d" (which is a file named "d.wren" in a directory "c"), then the canonical name is "c/a/b" and the file is "c/a/b.wren".</p>
<p class="startli">".." and "." are allowed and are normalized. So these imports all resolve to the same module:</p>
<p class="startli">```scala import "a/b/c" import "a/./b/./c" import "a/d/../b/c" ```</p>
</li>
<li><p class="startli">If an import is quoted, the path is considered relative to the importing module's path, and is in the same package as the importing module.</p>
<p class="startli">So, if the current file is "a/b/c.wren" in package "foo" then these are equivalent:</p>
<p class="startli">```scala import "d/e" import foo/a/b/d/e ```</p>
</li>
<li><p class="startli">If an import is unquoted, the first identifier is the logical "package" containing the module, and the remaining components are the path within that package. The canonicalized string is the logical name, a colon, then the resolved full path to the import (without the ".wren" file extension). So if you import:</p>
<p class="startli">```scala import wrenalyzer/ast/expr ```</p>
<p class="startli">The canonical name is "wrenalyzer:ast/expr".</p>
</li>
<li><p class="startli">If an import is a single unquoted name, the CLI implicitly uses the name as the module to look for within that package. These are equivalent:</p>
<p class="startli">```scala import foo import foo/foo ```</p>
<p class="startli">We could use some default name like "module" instead of the package name, similar to Python, but I think this is actually a little more usable in practice. If you're hacking on a bunch of packages at the same time, it's annoying if every tab in your text editor just says "module.wren".</p>
</li>
<li>The canonicalized string for the main script or a module imported using a relative path from the main script is just the normalized file path, probably relative to the working directory.</li>
<li>Since colon is used to separate the name from path, path components with colons are not allowed.</li>
</ul>
<h2><a class="anchor" id="autotoc_md99"></a>
Finding logical imports</h2>
<p>The last remaining piece is how the CLI physically locates logical imports. If you write:</p>
<div class="fragment"><div class="line">import foo</div>
</div><!-- fragment --><p>Where does it look for "foo"? Of course, if "foo" is built into the VM like "random", then that's easy. Likewise, if it's built into the CLI like "io", that's easy too.</p>
<p>Otherwise, it will try to find it on the file system. We don't have a package manager yet, so we need some kind of simple policy so you can "hand-author" the layout a package manager would produce. Borrowing from Node, the basic idea is pretty simple.</p>
<p>To find a logical import, the CLI starts in the directory that contains the main script (not the directory containing the module doing the import), and looks for a directory named "wren_modules". If not found there, it starts walking up parent directories until it finds one. If it does, it looks for the logical import inside there. So, if you import "foo", it will try to find "wren_modules/foo/foo.wren".</p>
<p>Once it finds a "wren_modules" directory, it uses that one directory for all logical imports. You can't scatter stuff across multiple "wren_modules" folders at different levels of the hierarchy. If it can't find a "wren_modules" directory, or it can't find the requested module inside the directory, the import fails.</p>
<p>This means that to reuse someone else's Wren "package" (or your own for that matter), you can just stick a "wren_modules" directory next to the main script for your app or in some parent directory. Inside that "wren_modules" directory, copy in the package you want to reuse. If that package in turn uses other packages, copy those into the <em>same</em> "wren_modules" directory. In other words, the transitive dependencies get flattened. This is important to handle shared dependencies between packages without duplication.</p>
<p>You only need to worry about all of this if you actually have logical imports. If you just have a couple of files that import each other, you can use straight relative imports and everything just works.</p>
<h1><a class="anchor" id="autotoc_md100"></a>
Migration</h1>
<p>OK, that's the plan. How do we get there? I've start hacking on the implementation a little and, so far, it seems straightforward. Honestly, it will probably take less time than I spent writing this up.</p>
<p>The tricky part is that this is a breaking change. All of your existing quoted import strings will mean something different. We definitely <em>can</em> and will make breaking changes in Wren, so that's OK, but I'd like to minimize the pain. Right now, Wren is currently at version 0.1.0. I'll probably consider the commit right before I start landing this to be the "official" 0.1.0 release and then the import changes will land in "0.2.0". I'll work in a branch off main until everything looks solid and then merge it in.</p>
<p>If you have existing Wren code that you run on the CLI and that contains imports, you'll probably need to tweak them.</p>
<p>If you are hosting Wren in your own app, the imports are fine since your app has control over how they resolve. But you will have to fix your app a little since the import embedding API is going to change to deal with canonicalization. I think I can make it so that if you don't provide a canonicalization callback, then the original import string is treated as the canonical string and you fall back to the current behavior.</p>
<h1><a class="anchor" id="autotoc_md101"></a>
Alternatives</h1>
<p>Having both quoted and unquoted import strings is a little funny, but it's the best I could come up with. For what it's worth, I <a href="https://docs.racket-lang.org/guide/module-basics.html">borrowed it from Racket</a>.</p>
<p>I considered a couple of other ideas which are potentially on the table if most of you don't dig the main proposal:</p>
<h2><a class="anchor" id="autotoc_md102"></a>
Node-style</h2>
<p>In Node, <a href="https://nodejs.org/api/modules.html">all imports are quoted</a>. To distinguish between relative and logical imports, relative imports always start with "./". In Wren, it would be:</p>
<div class="fragment"><div class="line">import &quot;./something/relative&quot;</div>
<div class="line">import &quot;logical/thing&quot;</div>
</div><!-- fragment --><p>This is simpler than the main proposal since there are no syntax changes and we don't need to push the "was quoted?" bit through the embedding API. But I find the "./" pretty unintuitive especially if you're not steeped in the UNIX tradition. Even if you are, it's weird that you <em>need</em> to use "./" when it means nothing to the filesystem.</p>
<h2><a class="anchor" id="autotoc_md103"></a>
Unquoted identifiers</h2>
<p>The other idea I had was to allow both an unquoted identifier and a quoted path, like:</p>
<div class="fragment"><div class="line">import wrenalyzer &quot;ast/expr&quot;</div>
</div><!-- fragment --><p>The unquoted name is the logical part — the package name. The quoted part is the path within that logical package. If you omit the unquoted name, it's a straight relative import. If you have a name but no path, it's desugars to use the name as the path.</p>
<p>This is a little more complex because we have to pass around the name and path separately between the VM and the host app during canonicalization. If we want the canonicalized form to keep those separate as well, then the way we keep track of previously-loaded modules needs to get more complex too. Likewise the way we show stack traces, etc.</p>
<p>The main proposal gloms everything into a single string using ":" to separate the logical name part from the path. That's a little arbitrary, but it keeps the VM a good bit simpler and means the idea of there being a "package name" is pure host app policy. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
