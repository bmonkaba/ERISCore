<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ERIS CORE: index</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ERIS CORE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dd/df3/md__e_r_i_s_core_lib_wren_doc_site_embedding_index.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">index </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>^title Embedding</p>
<p>Wren is designed to be a scripting language that lives inside a host application, so the embedding API is as important as any of its language features. Designing this API well requires satisfying several constraints:</p>
<ol type="1">
<li><b>Wren is dynamically typed, but C is not.</b> A variable can hold a value of any type in Wren, but that's definitely not the case in C unless you define some sort of variant type, which ultimately just kicks the problem down the road. Eventually, we have to move data across the boundary between statically and dynamically typed code.</li>
<li><p class="startli"><b>Wren uses garbage collection, but C manages memory manually.</b> GC adds a few constraints on the API. The VM must be able to find every Wren object that is still usable, even if that object is being referenced from native C code. Otherwise, Wren could free an object that's still in use.</p>
<p class="startli">Also, we ideally don't want to let native C code see a bare pointer to a chunk of memory managed by Wren. Many garbage collection strategies involve <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Copying_vs._mark-and-sweep_vs._mark-and-don.27t-sweep">moving objects</a> in memory. If we allow C code to point directly to an object, that pointer will be left dangling when the object moves. Wren's GC doesn't move objects today, but we would like to keep that option for the future.</p>
</li>
<li><b>The embedding API needs to be fast.</b> Users may add layers of abstraction on top of the API to make it more pleasant to work with, but the base API defines the <em>maximum</em> performance you can get out of the system. It's the bottom of the stack, so there's no way for a user to optimize around it if it's too slow. There is no lower level alternative.</li>
<li><b>We want the API to be pleasant to use.</b> This is the last constraint because it's the softest. Of course, we want a beautiful, usable API. But we really <em>need</em> to handle the above, so we're willing to make things a bit more of a chore to reach the first three goals.</li>
</ol>
<p>Fortunately, we aren't the first people to tackle this. If you're familiar with <a href="https://www.lua.org/pil/24.html">Lua's C API</a>, you'll find Wren's similar.</p>
<h3><a class="anchor" id="autotoc_md192"></a>
Performance and safety</h3>
<p>When code is safely snuggled within the confines of the VM, it's pretty safe. <a class="el" href="../../d4/d3e/struct_method.html">Method</a> calls are dynamically checked and generate runtime errors which can be caught and handled. The stack grows if it gets close to overflowing. In general, when you're within Wren code, it tries very hard to avoid crashing and burning.</p>
<p>This is why you use a high level language after all&mdash;it's safer and more productive than C. C, meanwhile, really assumes you know what you're doing. You can cast pointers in invalid ways, misinterpret bits, use memory after freeing it, etc. What you get in return is blazing performance. Many of the reasons C is fast are because it takes all the governors and guardrails off.</p>
<p>Wren's embedding API defines the border between those worlds, and takes on some of the characteristics of C. When you call any of the embedding API functions, it assumes you are calling them correctly. If you invoke a Wren method from C that expects three arguments, it trusts that you gave it three arguments.</p>
<p>In debug builds, Wren has assertions to check as many things as it can, but in release builds, Wren expects you to do the right thing. This means you need to take care when using the embedding API, just like you do in all C code you write. In return, you get an API that is quite fast.</p>
<h2><a class="anchor" id="autotoc_md193"></a>
Including Wren</h2>
<p>There are two (well, three) ways to get the Wren VM into your program:</p>
<ol type="1">
<li><b>Link to the static or dynamic library.</b> When you <a href="../../../getting-started.html">build Wren</a>, it generates both shared and static libraries in <code>lib</code> that you can link to.</li>
<li><b>Include the source directly in your application.</b> If you want to include the source directly in your program, you don't need to run any build steps. Just add the source files in <code>src/vm</code> to your project. They should compile cleanly as C99 or C++98 or anything later.</li>
</ol>
<p>In either case, you also want to add <code>src/include</code> to your include path so you can find the <a href="https://github.com/wren-lang/wren/blob/main/src/include/wren.h">public header for Wren</a>:</p>
<pre class="snippet" data-lang="c">
#include "wren.h"
</pre><p>Wren depends only on the C standard library, so you don't usually need to link to anything else. On some platforms (at least BSD and Linux) some of the math functions in <code>math.h</code> are implemented in a separate library, <a href="https://en.wikipedia.org/wiki/C_mathematical_functions#libm">libm</a>, that you have to explicitly link to.</p>
<p>If your program is in C++ but you are linking to the Wren library compiled as C, this header handles the differences in calling conventions between C and C++:</p>
<pre class="snippet" data-lang="c">
#include "wren.hpp"
</pre><h2><a class="anchor" id="autotoc_md194"></a>
Creating a Wren VM</h2>
<p>Once you've integrated the code into your executable, you need to create a virtual machine. To do that, you create a <code><a class="el" href="../../d5/df9/struct_wren_configuration.html">WrenConfiguration</a></code> object and initialize it.</p>
<pre class="snippet" data-lang="c">
    <a class="el" href="../../d5/df9/struct_wren_configuration.html">WrenConfiguration</a> config;
    wrenInitConfiguration(&amp;config);
</pre><p>This gives you a basic configuration that has reasonable defaults for everything. We'll <a href="../../configuring-the-vm.html">learn more</a> about what you can configure later, but for now we'll just add the <code>writeFn</code>, so that we can print text.</p>
<p>First we need a function that will do something with the output that Wren sends us from <code>System.print</code> (or <code>System.write</code>). <em>Note that it doesn't include a newline in the output.</em></p>
<pre class="snippet" data-lang="c">
void <a class="el" href="../../d0/d29/main_8c.html#ad0c26c660738b28a098f1400caef81e2">writeFn(WrenVM* vm, const char* text)</a> {
  printf("%s", text);
}
</pre><p>And then, we update the configuration to point to it.</p>
<pre class="snippet" data-lang="c">
  <a class="el" href="../../d5/df9/struct_wren_configuration.html">WrenConfiguration</a> config;
  wrenInitConfiguration(&amp;config);
    config.writeFn = 
</pre><p>With this ready, you can create the VM:</p>
<pre class="snippet" data-lang="c">
WrenVM* vm = wrenNewVM(&amp;config);
</pre><p>This allocates memory for a new VM and initializes it. The Wren C implementation has no global state, so every single bit of data Wren uses is bundled up inside a <a class="el" href="../../d7/ddb/struct_wren_v_m.html">WrenVM</a>. You can have multiple Wren VMs running independently of each other without any problems, even concurrently on different threads.</p>
<p><code><a class="el" href="../../dd/d19/wren_8h.html#a564a87c8703d1d01c6cc5d165e3c819a">wrenNewVM()</a></code> stores its own copy of the configuration, so after calling it, you can discard the <a class="el" href="../../d5/df9/struct_wren_configuration.html">WrenConfiguration</a> struct you filled in. Now you have a live VM, waiting to run some code!</p>
<h2><a class="anchor" id="autotoc_md196"></a>
Executing Wren code</h2>
<p>You execute a string of Wren source code like so:</p>
<pre class="snippet" data-lang="c">
WrenInterpretResult result = wrenInterpret(
    vm,
    "my_module",
    "System.print(\"I am running in a VM!")");
</pre><p>The string is a series of one or more statements separated by newlines. Wren copies the string, so you can free it after calling this. When you call <code><a class="el" href="../../dd/d19/wren_8h.html#a653b065ece2f5fb52dc3ff41e7c8322a">wrenInterpret()</a></code>, Wren first compiles your source to bytecode. If an error occurs, it returns immediately with <code>WREN_RESULT_COMPILE_ERROR</code>.</p>
<p>Otherwise, Wren spins up a new <a href="../../../concurrency.html">fiber</a> and executes the code in that. Your code can in turn spawn whatever other fibers it wants. It keeps running fibers until they all complete or one <a href="../../../modules/core/fiber.html#fiber.suspend()">suspends</a>.</p>
<p>If a <a href="../../../error-handling.html">runtime error</a> occurs (and another fiber doesn't handle it), Wren aborts fibers all the way back to the main one and returns <code>WREN_RESULT_RUNTIME_ERROR</code>. Otherwise, when the last fiber successfully returns, it returns <code>WREN_RESULT_SUCCESS</code>.</p>
<p>All code passed to <code><a class="el" href="../../dd/d19/wren_8h.html#a653b065ece2f5fb52dc3ff41e7c8322a">wrenInterpret()</a></code> runs in a special "main" module. That way, top-level names defined in one call can be accessed in later ones. It's similar to a REPL session.</p>
<h2><a class="anchor" id="autotoc_md197"></a>
Shutting down a VM</h2>
<p>Once the party is over and you're ready to end your relationship with a VM, you need to free any memory it allocated. You do that like so:</p>
<pre class="snippet" data-lang="c">
wrenFreeVM(vm);
</pre><p>After calling that, you obviously cannot use the <code>WrenVM*</code> you passed to it again. It's dead.</p>
<p>Note that Wren will yell at you if you still have any live <a href="../../slots-and-handles.html#handles">WrenHandle</a> objects when you call this. This makes sure you haven't lost track of any of them (which leaks memory) and you don't try to use any of them after the VM has been freed.</p>
<h2><a class="anchor" id="autotoc_md199"></a>
A complete example</h2>
<p>Below is a complete example of the above. You can find this file in the <a href="https://github.com/wren-lang/wren/blob/main/example/embedding/main.c">example</a> folder.</p>
<pre class="snippet" data-lang="c">
//For more details, visit <a href="https://wren.io/embedding/">https://wren.io/embedding/</a>

#include &lt;stdio.h&gt;
#include "wren.h"

static void <a class="el" href="../../d0/d29/main_8c.html#ad0c26c660738b28a098f1400caef81e2">writeFn(WrenVM* vm, const char* text)</a>
{
  printf("%s", text);
}

void errorFn(WrenVM* vm, WrenErrorType errorType,
             const char* module, const int line,
             const char* msg)
{
  switch (errorType)
  {
    case WREN_ERROR_COMPILE:
    {
      printf("[%s line %d] [Error] %s\n", module, line, msg);
    } break;
    case WREN_ERROR_STACK_TRACE:
    {
      printf("[%s line %d] in %s\n", module, line, msg);
    } break;
    case WREN_ERROR_RUNTIME:
    {
      printf("[Runtime Error] %s\n", msg);
    } break;
  }
}

int <a class="el" href="../../d0/d29/main_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>
{

  <a class="el" href="../../d5/df9/struct_wren_configuration.html">WrenConfiguration</a> config;
  wrenInitConfiguration(&amp;config);
    config.writeFn = 
    config.errorFn = 
  WrenVM* vm = wrenNewVM(&amp;config);

  const char* module = "main";
  const char* script = "System.print(\"I am running in a VM!")";

  WrenInterpretResult result = wrenInterpret(vm, module, script);

  switch (result) {
    case WREN_RESULT_COMPILE_ERROR:
      { printf("Compile Error!\n"); } break;
    case WREN_RESULT_RUNTIME_ERROR:
      { printf("Runtime Error!\n"); } break;
    case WREN_RESULT_SUCCESS:
      { printf("Success!\n"); } break;
  }

  wrenFreeVM(vm);

}
</pre><p>Next, we'll learn to make that VM do useful stuff...</p>
<p><a href="../../slots-and-handles.html" class="right">Slots and Handles &rarr;</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
