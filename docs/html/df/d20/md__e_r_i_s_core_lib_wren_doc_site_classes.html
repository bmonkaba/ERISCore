<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ERIS CORE: classes</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ERIS CORE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('df/d20/md__e_r_i_s_core_lib_wren_doc_site_classes.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">classes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>^title Classes</p>
<p>Every value in Wren is an object, and every object is an instance of a class. Even <code>true</code> and <code>false</code> are full-featured objects&mdash;instances of the <a href="../../modules/core/bool.html">Bool</a> class.</p>
<p>Classes define an objects <em>behavior</em> and <em>state</em>. Behavior is defined by <a href="../../method-calls.html"><em>methods</em></a> which live in the class. Every object of the same class supports the same methods. State is defined in <em>fields</em>, whose values are stored in each instance.</p>
<h2><a class="anchor" id="autotoc_md164"></a>
Defining a class</h2>
<p>Classes are created using the <code>class</code> keyword, unsurprisingly:</p>
<pre class="snippet">
class Unicorn {}
</pre><p>This creates a class named <code>Unicorn</code> with no methods or fields.</p>
<h2><a class="anchor" id="autotoc_md165"></a>
Methods</h2>
<p>To let our unicorn do stuff, we need to give it methods.</p>
<pre class="snippet">
class Unicorn {
  prance() {
    System.print("The unicorn prances in a fancy manner!")
  }
}
</pre><p>This defines a <code>prance()</code> method that takes no arguments. To add parameters, put their names inside the parentheses:</p>
<pre class="snippet">
class Unicorn {
  prance(where, when) {
    System.print("The unicorn prances in %(where) at %(when).")
  }
}
</pre><p>Since the number of parameters is part of a method's <a href="../../method-calls.html#signature">signature</a> a class can define multiple methods with the same name:</p>
<pre class="snippet">
class Unicorn {
  prance() {
    System.print("The unicorn prances in a fancy manner!")
  }

  prance(where) {
    System.print("The unicorn prances in %(where).")
  }

  prance(where, when) {
    System.print("The unicorn prances in %(where) at %(when).")
  }
}
</pre><p>It's often natural to have the same conceptual operation work with different sets of arguments. In other languages, you'd define a single method for the operation and have to check for missing optional arguments. In Wren, they are different methods that you implement separately.</p>
<p>In addition to named methods with parameter lists, Wren has a bunch of other different syntaxes for methods. Your classes can define all of them.</p>
<h3><a class="anchor" id="autotoc_md166"></a>
Getters</h3>
<p>A getter leaves off the parameter list and the parentheses:</p>
<pre class="snippet">
class Unicorn {
  // Unicorns are always fancy.
  isFancy { true }
}
</pre><h3><a class="anchor" id="autotoc_md167"></a>
Setters</h3>
<p>A setter has <code>=</code> after the name, followed by a single parenthesized parameter:</p>
<pre class="snippet">
class Unicorn {
  rider=(value) {
    System.print("I am being ridden by %(value).")
  }
}
</pre><p>By convention, the parameter is usually named <code>value</code> but you can call it whatever makes your heart flutter.</p>
<h3><a class="anchor" id="autotoc_md168"></a>
Operators</h3>
<p>Prefix operators, like getters, have no parameter list:</p>
<pre class="snippet">
class Unicorn {<ul>
<li>{
    System.print("Negating a unicorn is weird.")
  }
}
</li>
</ul>
</pre><pre class="snippet">Infix operators, like setters, have a single parenthesized parameter for the
right-hand operand:</pre><pre class="snippet"><pre class="snippet">
class Unicorn {
  -(other) {
    System.print("Subtracting %(other) from a unicorn is weird.")
  }
}
</pre></pre><pre class="snippet">A subscript operator puts the parameters inside square brackets and can have
more than one:</pre><pre class="snippet"><pre class="snippet">
class Unicorn {
  [index] {
    System.print("Unicorns are not lists!")
  }

  [x, y] {
    System.print("Unicorns are not matrices either!")
  }
}
</pre></pre><pre class="snippet">Unlike with named methods, you can't define a subscript operator with an empty
parameter list.</pre><pre class="snippet">As the name implies, a subscript setter looks like a combination of a subscript
operator and a setter:</pre><pre class="snippet"><pre class="snippet">
class Unicorn {
  [index]=(value) {
    System.print("You can't stuff %(value) into me at %(index)!")
  }
}
</pre></pre><pre class="snippet"></pre><h2><a class="anchor" id="autotoc_md169"></a>
Method Scope</h2>
<pre class="snippet">
Up to this point, "[scope][]" has been used to talk exclusively about
<a href="../../variables.html">variables</a>. In a procedural language like C, or a functional one like Scheme,
that's the only kind of scope there is. But object-oriented languages like Wren
introduce another kind of scope: <em>object scope</em>. It contains the methods that
are available on an object. When you write:</pre><pre class="snippet"><pre class="snippet">
unicorn.isFancy
</pre></pre><pre class="snippet">You're saying "look up the method <code>isFancy</code> in the scope of the object
<code>unicorn</code>&rdquo;. In this case, the fact that you want to look up a <em>method</em>
<code>isFancy</code> and not a <em>variable</em> <code>isFancy</code> is explicit. That's what <code>.</code> does and
the object to the left of the period is the object you want to look up the
method on.</pre><pre class="snippet"></pre><h3><a class="anchor" id="autotoc_md172"></a>
&lt;tt&gt;this&lt;/tt&gt;</h3>
<pre class="snippet">
Things get more interesting when you're inside the body of a method. When the
method is called on some object and the body is being executed, you often need
to access that object itself. You can do that using <code>this</code>.</pre><pre class="snippet"><pre class="snippet">
class Unicorn {
  name { "Francis" }

  printName() {
    System.print(this.name) //&gt; Francis
  }
}
</pre></pre><pre class="snippet">The <code>this</code> keyword works sort of like a variable, but has special behavior. It
always refers to the instance whose method is currently being executed. This
lets you invoke methods on "yourself".</pre><pre class="snippet">It's an error to refer to <code>this</code> outside of a method. However, it's perfectly
fine to use it inside a <a href="../../functions.html">function</a> declared <em>inside</em> a method. When you do,
<code>this</code> still refers to the instance whose <em>method</em> is being called:</pre><pre class="snippet"><pre class="snippet">
class Unicorn {
  name { "Francis" }

  printNameThrice() {
    (1..3).each {
      // Use "this" inside the function passed to each().
      System.print(this.name) //&gt; Francis
    } //&gt; Francis
  } //&gt; Francis
}
</pre></pre><pre class="snippet">This is unlike Lua and JavaScript which can "forget" <code>this</code> when you create a
callback inside a method. Wren does what you want here and retains the
reference to the original object.</pre><pre class="snippet">(In technical terms, a function's closure includes <code>this</code>. Wren can do this
because it makes a distinction between methods and functions.)</pre><pre class="snippet"></pre><h3><a class="anchor" id="autotoc_md182"></a>
Implicit &lt;tt&gt;this&lt;/tt&gt;</h3>
<pre class="snippet">
Using <code>this.</code> every time you want to call a method on yourself works, but it's
tedious and verbose, which is why some languages don't require it. You can do a
"self send" by calling a method (or getter or setter) without any explicit
receiver:</pre><pre class="snippet"><pre class="snippet">
class Unicorn {
  name { "Francis" }

  printName() {
    System.print(name) //&gt; Francis
  }
}
</pre></pre><pre class="snippet">Code like this gets tricky when there is also a variable outside of the class
with the same name. Consider:</pre><pre class="snippet"><pre class="snippet">
var name = "variable"

class Unicorn {
  name { "Francis" }

  printName() {
    System.print(name) // ???
  }
}
</pre></pre><pre class="snippet">Should <code>printName()</code> print "variable" or "Francis"? A method body has a foot in
each of two worlds. It is surrounded by the lexical scope where it's defined in
the program, but it also has the object scope of the methods on <code>this</code>.</pre><pre class="snippet">Which scope wins? Every language has to decide how to handle this and there
is a surprising plethora of approaches. Wren's approach to resolving a name
inside a method works like this:</pre><pre class="snippet"><ol type="1">
<li>If there is a local variable inside the method with that name, that wins.</li>
<li>Else, if the name starts with a lowercase letter, treat it like a method on
    <code>this</code>.</li>
<li>Otherwise, look for a variable with that name in the surrounding scope.</li>
</ol>
</pre><pre class="snippet">So, in the above example, we hit case #2 and it prints "Francis". Distinguishing
self sends from outer variables based on the <em>case</em> of the first letter in the
name probably seems weird but it works surprisingly well. <a class="el" href="../../d4/d3e/struct_method.html">Method</a> names are
lowercase in Wren. Class names are capitalized.</pre><pre class="snippet">Most of the time, when you're in a method and want to access a name from outside
of the class, it's usually the name of some other class. This rule makes that
work.</pre><pre class="snippet">Here's an example that shows all three cases:</pre><pre class="snippet"><pre class="snippet">
var shadowed = "surrounding"
var lowercase = "surrounding"
var Capitalized = "surrounding"

class Scope {
  shadowed { "object" }
  lowercase { "object" }
  Capitalized { "object" }

  test() {
    var shadowed = "local"

    System.print(shadowed) //&gt; local
    System.print(lowercase) //&gt; object
    System.print(Capitalized) //&gt; surrounding
  }
}
</pre></pre><pre class="snippet">It's a bit of a strange rule, but Ruby works more or less the same way.</pre><pre class="snippet"></pre><h2><a class="anchor" id="autotoc_md184"></a>
Constructors</h2>
<pre class="snippet">
We've seen how to define kinds of objects and how to declare methods on them.
Our unicorns can prance around, but we don't actually <em>have</em> any unicorns to do
it. To create <em>instances</em> of a class, we need a <em>constructor</em>. You define one
like so:</pre><pre class="snippet"><pre class="snippet">
class Unicorn {
  construct new(name, color) {
    System.print("My name is " + name + " and I am " + color + ".")
  }
}
</pre></pre><pre class="snippet">The <code>construct</code> keyword says we're defining a constructor, and <code>new</code> is its
name. In Wren, all constructors have names. The word "new" isn't special to
Wren, it's just a common constructor name.</pre><pre class="snippet">To make a unicorn now, we call the constructor method on the class itself:</pre><pre class="snippet"><pre class="snippet">
var fred = Unicorn.new("Fred", "palomino")
</pre></pre><pre class="snippet">Giving constructors names is handy because it means you can have more than one,
and each can clarify how it creates the instance:</pre><pre class="snippet"><pre class="snippet">
class Unicorn {
  construct brown(name) {
    System.print("My name is " + name + " and I am brown.")
  }
}

var dave = Unicorn.brown("Dave")
</pre></pre><pre class="snippet">Note that we have to declare a constructor because, unlike some other
languages, Wren doesn't give you a default one. This is useful because some
classes aren't designed to be constructed. If you have an abstract base class
that just contains methods to be inherited by other classes, it doesn't need
and won't have a constructor.</pre><pre class="snippet">Like other methods, constructors can obviously have arguments, and can be
overloaded by <a href="../../#signature">arity</a>. A constructor <em>must</em> be a named method with
a (possibly empty) argument list. Operators, getters, and setters cannot be
constructors.</pre><pre class="snippet">A constructor returns the instance of the class being created, even if you 
don't explicitly use <code>return</code>. It is valid to use <code>return</code> inside of a 
constructor, but it is an error to have an expression after the return.
That rule applies to <code>return this</code> as well, return handles that implicitly inside
a constructor, so just <code>return</code> is enough.</pre><pre class="snippet"><pre class="snippet">
return          //&gt; valid, returns 'this'

return variable //&gt; invalid
return null     //&gt; invalid
return this     //&gt; also invalid
</pre></pre><pre class="snippet">A constructor is actually a pair of methods. You get a method on the class:</pre><pre class="snippet"><pre class="snippet">
Unicorn.brown("Dave")
</pre></pre><pre class="snippet">That creates the new instance, then it invokes the <em>initializer</em> on that
instance. This is where the constructor body you defined gets run.</pre><pre class="snippet">This distinction is important because it means inside the body of the
constructor, you can access <code>this</code>, assign <a href="../../#fields">fields</a>, call superclass
constructors, etc.</pre><pre class="snippet"></pre><h2><a class="anchor" id="autotoc_md185"></a>
Fields</h2>
<pre class="snippet">
All state stored in instances is stored in <em>fields</em>. Each field has a name
that starts with an underscore.</pre><pre class="snippet"><pre class="snippet">
class Rectangle {
  area { _width * _height }

  // Other stuff...
}
</pre></pre><pre class="snippet">Here, <code>_width</code> and <code>_height</code> in the <code>area</code> <a href="../../classes.html#methods">getter</a> refer
to fields on the rectangle instance. You can think of them like <code>this.width</code>
and <code>this.height</code> in other languages.</pre><pre class="snippet">When a field name appears, Wren looks for the nearest enclosing class and looks
up the field on the instance of that class. Field names cannot be used outside
of an instance method. They <em>can</em> be used inside a <a href="../../functions.html">function</a>
in a method. Wren will look outside any nested functions until it finds an
enclosing method.</pre><pre class="snippet">Unlike <a href="../../variables.html">variables</a>, fields are implicitly declared by simply
assigning to them. If you access a field before it has been initialized, its
value is <code>null</code>.</pre><pre class="snippet"></pre><h3><a class="anchor" id="autotoc_md186"></a>
Encapsulation</h3>
<pre class="snippet">
All fields are <em>private</em> in Wren&mdash;an object's fields can only be directly
accessed from within methods defined on the object's class.</pre><pre class="snippet">In short, if you want to make a property of an object visible,
<b>you need to define a getter to expose it</b>:</pre><pre class="snippet"><pre class="snippet">
class Rectangle {
  width { _width }
  height { _height }

  // ...
}
</pre></pre><pre class="snippet">To allow outside code to modify the field,
<b>you need to provide setters to provide access</b>:</pre><pre class="snippet"><pre class="snippet">
class Rectangle {
  width=(value) { _width = value }
  height=(value) { _height = value }
}
</pre></pre><pre class="snippet">This might be different from what you're used to, so here are two important facts:</pre><pre class="snippet"><ul>
<li>You can't access fields from a base class.</li>
<li>You can't access fields on another instance of your own class.</li>
</ul>
</pre><pre class="snippet">Here is an example in code:</pre><pre class="snippet"><pre class="snippet">
class Shape {
  construct new() {
    _shape = "none"
  }
}

class Rectangle is Shape {
  construct new() {
    //This will print null!
    //_shape from the parent class is private,
    //we are reading `_shape` from `this`,
    //which has not been set, so returns null.
    System.print("I am a %(_shape)")

    //a local variable, all variables are private
    _width = 10
    var other = Rectangle.new()

    //other._width is not accessible from here,
    //even though we are also a rectangle. The field
    //is private, and other._width is invalid syntax!
  }
}
...
</pre></pre><pre class="snippet">One thing we've learned in the past forty years of software engineering is that
encapsulating state tends to make code easier to maintain, so Wren defaults to
keeping your object's state pretty tightly bundled up. Don't feel that you have
to or even should define getters or setters for most of your object's fields.</pre><pre class="snippet"></pre><h2><a class="anchor" id="autotoc_md187"></a>
Metaclasses and static members</h2>
<pre class="snippet">
<b>TODO</b></pre><pre class="snippet"></pre><h3><a class="anchor" id="autotoc_md188"></a>
Static fields</h3>
<pre class="snippet">
A name that starts with <em>two</em> underscores is a <em>static</em> field. They work
similar to <a href="../../#fields">fields</a> except the data is stored on the class itself, and
not the instance. They can be used in <em>both</em> instance and static methods.</pre><pre class="snippet"><pre class="snippet">
class Foo {
  construct new() {}

  static setFromStatic(a) { __a = a }
  setFromInstance(a) { __a = a }

  static printFromStatic() {
    System.print(__a)
  }

  printFromInstance() {
    System.print(__a)
  }
}
</pre></pre><pre class="snippet">Just like instance fields, static fields are initially <code>null</code>:</pre><pre class="snippet"><pre class="snippet">
Foo.printFromStatic() //&gt; null
</pre></pre><pre class="snippet">They can be used from static methods:</pre><pre class="snippet"><pre class="snippet">
Foo.setFromStatic("first")
Foo.printFromStatic() //&gt; first
</pre></pre><pre class="snippet">And also instance methods. When you do so, there is still only one static field
shared among all instances of the class:</pre><pre class="snippet"><pre class="snippet">
var foo1 = Foo.new()
var foo2 = Foo.new()

foo1.setFromInstance("second")
foo2.printFromInstance() //&gt; second
</pre></pre><pre class="snippet"></pre><h2><a class="anchor" id="autotoc_md189"></a>
Inheritance</h2>
<pre class="snippet">
A class can inherit from a "parent" or <em>superclass</em>. When you invoke a method
on an object of some class, if it can't be found, it walks up the chain of
superclasses looking for it there.</pre><pre class="snippet">By default, any new class inherits from Object, which is the superclass from
which all other classes ultimately descend. You can specify a different parent
class using <code>is</code> when you declare the class:</pre><pre class="snippet"><pre class="snippet">
class Pegasus is Unicorn {}
</pre></pre><pre class="snippet">This declares a new class Pegasus that inherits from Unicorn.</pre><pre class="snippet">Note that you should not create classes that inherit from the built-in types
(Bool, Num, String, Range, List). The built-in types expect their internal bit
representation to be very specific and get horribly confused when you invoke one
of the inherited built-in methods on the derived type.</pre><pre class="snippet">The metaclass hierarchy does <em>not</em> parallel the regular class hierarchy. So, if
Pegasus inherits from Unicorn, Pegasus's metaclass does not inherit from
Unicorn's metaclass. In more prosaic terms, this means that static methods are
not inherited.</pre><pre class="snippet"><pre class="snippet">
class Unicorn {
  // Unicorns cannot fly. :(
  static canFly { false }
}

class Pegasus is Unicorn {}

Pegasus.canFly //! Static methods are not inherited.
</pre></pre><pre class="snippet">This also means constructors are not inherited:</pre><pre class="snippet"><pre class="snippet">
class Unicorn {
  construct new(name) {
    System.print("My name is " + name + ".")
  }
}

class Pegasus is Unicorn {}

Pegasus.new("Fred") //! Pegasus does not define new().
</pre></pre><pre class="snippet">Each class gets to control how it may be constructed independently of its base
classes. However, constructor <em>initializers</em> are inherited since those are
instance methods on the new object.</pre><pre class="snippet">This means you can do <code>super</code> calls inside a constructor:</pre><pre class="snippet"><pre class="snippet">
class Unicorn {
  construct new(name) {
    System.print("My name is " + name + ".")
  }
}

class Pegasus is Unicorn {
  construct new(name) {
    super(name)
  }
}

Pegasus.new("Fred") //&gt; My name is Fred
</pre></pre><pre class="snippet"></pre><h2><a class="anchor" id="autotoc_md190"></a>
Super</h2>
<pre class="snippet">
<b>TODO: Integrate better into page. Should explain this before mentioning
super above.</b></pre><pre class="snippet">Sometimes you want to invoke a method on yourself, but using methods defined in
one of your <a href="../../classes.html#inheritance">superclasses</a>. You typically do this in
an overridden method when you want to access the original method being
overridden.</pre><pre class="snippet">To do that, you can use the special <code>super</code> keyword as the receiver in a method
call:</pre><pre class="snippet"><pre class="snippet">
class Base {
  <a class="el" href="../../d4/de2/wren__compiler_8c.html#a280648a47237a52319d293ace8edb7c8">method()</a> {
    System.print("base method")
  }
}

class Derived is Base {
  <a class="el" href="../../d4/de2/wren__compiler_8c.html#a280648a47237a52319d293ace8edb7c8">method()</a> {
    super.method() //&gt; base method
  }
}
</pre></pre><pre class="snippet">You can also use <code>super</code> without a method name inside a constructor to invoke a
base class constructor:</pre><pre class="snippet"><pre class="snippet">
class Base {
  construct new(arg) {
    System.print("base got " + arg)
  }
}

class Derived is Base {
  construct new() {
    super("value") //&gt; base got value
  }
}
</pre></pre><pre class="snippet"></pre><h2><a class="anchor" id="autotoc_md191"></a>
Attributes</h2>
<pre class="snippet">
<small><b>experimental stage</b>: subject to minor changes</small></pre><pre class="snippet">A class and methods within a class can be tagged with 'meta attributes'.</pre><pre class="snippet">Like this:</pre><pre class="snippet"><pre class="snippet">
#hidden = true
class Example {}
</pre></pre><pre class="snippet">These attributes are metadata, they give you a way to annotate and store
any additional information about a class, which you can optionally access at runtime.
This information can also be used by external tools, to provide additional
hints and information from code to the tool.</pre><pre class="snippet"><small>
Since this feature has just been introduced, <b>take note</b>.</small></pre><pre class="snippet"><small><b>Currently</b> there are no attributes with a built-in meaning. 
Attributes are user-defined metadata. This may not remain 
true as some may become well defined through convention or potentially
through use by Wren itself. 
</small></pre><pre class="snippet">Attributes are placed before a class or method definition,
and use the <code>#</code> hash/pound symbol.</pre><pre class="snippet">They can be</pre><pre class="snippet"><ul>
<li>a <code>#key</code> on it's own</li>
<li>a <code>#key = value</code></li>
<li>a <code>#group(with, multiple = true, keys = "value")</code></li>
</ul>
</pre><pre class="snippet">An attribute <em>key</em> can only be a <code>Name</code>. This is the same type of name 
as a method name, a class name or variable name, an identifier that matches
the Wren identifier rules. A name results in a String value at runtime.</pre><pre class="snippet">An attribute <em>value</em> can be any of these literal values: <code>Name, String, Bool, Num</code>.
Values cannot contain expressions, just a value, there is no compile time 
evaluation.</pre><pre class="snippet">Groups can span multiple lines, methods have their own attributes, and duplicate
keys are valid.</pre><pre class="snippet"><pre class="snippet">
#key
#key = value
#group(
  multiple,
  lines = true,
  lines = 0
)
class Example {
  #test(skip = true, iterations = 32)
  doStuff() {}
}
</pre></pre><pre class="snippet"></pre><h3><a class="anchor" id="autotoc_md192"></a>
Accessing attributes at runtime</h3>
<pre class="snippet">
By default, attributes are compiled out and ignored.</pre><pre class="snippet">For an attribute to be visible at runtime, mark it for runtime
access using an exclamation:</pre><pre class="snippet"><pre class="snippet">
#doc = "not runtime data"
#!runtimeAccess = true
#!maxIterations = 16
</pre></pre><pre class="snippet">Attributes at runtime are stored on the class. You can access them via 
<code>YourClass.attributes</code>. The <code>attributes</code> field on a class will 
be null if a class has no attributes or if it's attributes aren't marked.</pre><pre class="snippet">If the class contains class or method attributes, it will be an object with
two getters:</pre><pre class="snippet"><ul>
<li><code>YourClass.attributes.self</code> for the class attributes</li>
<li><code>YourClass.attributes.methods</code> for the method attributes</li>
</ul>
</pre><pre class="snippet">Attributes are stored by group in a regular Wren Map. 
Keys that are not grouped, use <code>null</code> as the group key.</pre><pre class="snippet">Values are stored in a list, since duplicate keys are allowed, multiple
values need to be stored. They're stored in order of definition.</pre><pre class="snippet"><a class="el" href="../../d4/d3e/struct_method.html">Method</a> attributes are stored in a map by method signature, and each method
has it's own attributes that match the above structure. The method signature
is prefixed by <code>static</code> or <code>foreign static</code> as needed.</pre><pre class="snippet">Let's see what that looks like:</pre><pre class="snippet"><pre class="snippet">
// Example.attributes.self = 
// { 
//   null: { "key":[null] }, 
//   group: { "key":[value, 32, false] }
// }

#!key
#ignored //compiled out
#!group(key=value, key=32, key=false)
class Example {
  #!getter
  getter {}

  // { regular(_,_): { null: { regular:[null] } } }
  #!regular
  regular(arg0, arg1) {}

  // { static other(): { null: { isStatic:[true] } } }
  #!isStatic = true
  static other() {}

  // { foreign static example(): { null: { isForeignStatic:[32] } } }
  #!isForeignStatic=32
  foreign static example()
}
</pre></pre><pre class="snippet"><br  />
<hr  />

<a href="../../concurrency.html" class="right">Concurrency &rarr;</a>
<a href="../../functions.html">&larr; Functions</a>
</pre></div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
