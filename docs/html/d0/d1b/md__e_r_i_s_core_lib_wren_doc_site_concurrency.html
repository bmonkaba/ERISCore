<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ERIS CORE: concurrency</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ERIS CORE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d0/d1b/md__e_r_i_s_core_lib_wren_doc_site_concurrency.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">concurrency </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>^title Concurrency</p>
<p>Lightweight concurrency is a key feature of Wren and it is expressed using <em>fibers</em>. They control how all code is executed, and take the place of exceptions in <a href="../../error-handling.html">error handling</a>.</p>
<p>Fibers are a bit like threads except they are <em>cooperatively</em> scheduled. That means Wren doesn't pause one fiber and switch to another until you tell it to. You don't have to worry about context switches at random times and all of the headaches those cause.</p>
<p>Wren takes care of all of the fibers in the VM, so they don't use OS thread resources, or require heavyweight context switches. Each just needs a bit of memory for its stack. A fiber will get garbage collected like any other object when not referenced any more, so you can create them freely.</p>
<p>They are lightweight enough that you can, for example, have a separate fiber for each entity in a game. Wren can handle thousands of them without breaking a sweat. For example, when you run Wren in interactive mode, it creates a new fiber for every line of code you type in.</p>
<h2><a class="anchor" id="autotoc_md204"></a>
Creating fibers</h2>
<p>All Wren code runs within the context of a fiber. When you first start a Wren script, a main fiber is created for you automatically. You can spawn new fibers using the Fiber class's constructor:</p>
<pre class="snippet">
var fiber = Fiber.new {
  System.print("This runs in a separate fiber.")
}
</pre><p>It takes a <a href="../../functions.html">function</a> containing the code the fiber should execute. The function can take zero or one parameter, but no more than that. Creating the fiber does not immediately run it. It just wraps the function and sits there, waiting to be activated.</p>
<h2><a class="anchor" id="autotoc_md205"></a>
Invoking fibers</h2>
<p>Once you've created a fiber, you run it by calling its <code><a class="el" href="../../d4/de2/wren__compiler_8c.html#abc28d53c9cefc405f7f74cd877d037d1">call()</a></code> method:</p>
<pre class="snippet">
fiber.call()
</pre><p>This suspends the current fiber and executes the called one until it reaches the end of its body or until it passes control to yet another fiber. If it reaches the end of its body, it is considered <em>done</em>:</p>
<pre class="snippet">
var fiber = Fiber.new {
  System.print("It's alive!")
}

System.print(fiber.isDone) //&gt; false
fiber.call() //&gt; It's alive!
System.print(fiber.isDone) //&gt; true
</pre><p>When a called fiber finishes, it automatically passes control <em>back</em> to the fiber that called it. It's a runtime error to try to call a fiber that is already done.</p>
<h2><a class="anchor" id="autotoc_md207"></a>
Yielding</h2>
<p>The main difference between fibers and functions is that a fiber can be suspended in the middle of its operation and then resumed later. Calling another fiber is one way to suspend a fiber, but that's more or less the same as one function calling another.</p>
<p>Things get interesting when a fiber <em>yields</em>. A yielded fiber passes control <em>back</em> to the fiber that ran it, but <em>remembers where it is</em>. The next time the fiber is called, it picks up right where it left off and keeps going.</p>
<p>You make a fiber yield by calling the static <code>yield()</code> method on Fiber:</p>
<pre class="snippet">
var fiber = Fiber.new {
  System.print("Before yield")
  Fiber.yield()
  System.print("Resumed")
}

System.print("Before call") //&gt; Before call
fiber.call() //&gt; Before yield
System.print("Calling again") //&gt; Calling again
fiber.call() //&gt; Resumed
System.print("All done") //&gt; All done
</pre><p>Note that even though this program uses <em>concurrency</em>, it is still <em>deterministic</em>. You can reason precisely about what it's doing and aren't at the mercy of a thread scheduler playing Russian roulette with your code.</p>
<h2><a class="anchor" id="autotoc_md208"></a>
Passing values</h2>
<p>Calling and yielding fibers is used for passing control, but it can also pass <em>data</em>. When you call a fiber, you can optionally pass a value to it.</p>
<p>If you create a fiber using a function that takes a parameter, you can pass a value to it through <code><a class="el" href="../../d4/de2/wren__compiler_8c.html#abc28d53c9cefc405f7f74cd877d037d1">call()</a></code>:</p>
<pre class="snippet">
var fiber = Fiber.new {|param|
  System.print(param)
}

fiber.call("Here you go") //&gt; Here you go
</pre><p>If the fiber has yielded and is waiting to resume, the value you pass to call becomes the return value of the <code>yield()</code> call when it resumes:</p>
<pre class="snippet">
var fiber = Fiber.new {|param|
  System.print(param)
  var result = Fiber.yield()
  System.print(result)
}

fiber.call("First") //&gt; First
fiber.call("Second") //&gt; Second
</pre><p>Fibers can also pass values <em>back</em> when they yield. If you pass an argument to <code>yield()</code>, that will become the return value of the <code><a class="el" href="../../d4/de2/wren__compiler_8c.html#abc28d53c9cefc405f7f74cd877d037d1">call()</a></code> that was used to invoke the fiber:</p>
<pre class="snippet">
var fiber = Fiber.new {
  Fiber.yield("Reply")
}

System.print(fiber.call()) //&gt; Reply
</pre><p>This is sort of like how a function call may return a value, except that a fiber may return a whole sequence of values, one every time it yields.</p>
<h2><a class="anchor" id="autotoc_md209"></a>
Full coroutines</h2>
<p>What we've seen so far is very similar to what you can do with languages like Python and C# that have <em>generators</em>. Those let you define a function call that you can suspend and resume. When using the function, it appears like a sequence you can iterate over.</p>
<p>Wren's fibers can do that, but they can do much more. Like Lua, they are full <em>coroutines</em>&mdash;they can suspend from anywhere in the callstack. The function you use to create a fiber can call a method that calls another method that calls some third method which finally calls yield. When that happens, <em>all</em> of those method calls &mdash; the entire callstack &mdash; gets suspended. For example:</p>
<pre class="snippet">
var fiber = Fiber.new {
  (1..10).each {|i|
    Fiber.yield(i)
  }
}
</pre><p>Here, we're calling <code>yield()</code> from within a <a href="../../functions.html">function</a> being passed to the <code>each()</code> method. This works fine in Wren because that inner <code>yield()</code> call will suspend the call to <code>each()</code> and the function passed to it as a callback.</p>
<h2><a class="anchor" id="autotoc_md211"></a>
Transferring control</h2>
<p>Fibers have one more trick up their sleeves. When you execute a fiber using <code><a class="el" href="../../d4/de2/wren__compiler_8c.html#abc28d53c9cefc405f7f74cd877d037d1">call()</a></code>, the fiber tracks which fiber it will return to when it yields. This lets you build up a chain of fiber calls that will eventually unwind back to the main fiber when all of the called ones yield or finish.</p>
<p>This is usually what you want. But if you're doing something low level, like writing your own scheduler to manage a pool of fibers, you may not want to treat them explicitly like a stack.</p>
<p>For rare cases like that, fibers also have a <code>transfer()</code> method. This switches execution to the transferred fiber and "forgets" the fiber that was transferred <em>from</em>. The previous one is suspended, leaving it in whatever state it was in. You can resume the previous fiber by explicitly transferring back to it, or even calling it. If you don't, execution stops when the last transferred fiber returns.</p>
<p>Where <code><a class="el" href="../../d4/de2/wren__compiler_8c.html#abc28d53c9cefc405f7f74cd877d037d1">call()</a></code> and <code>yield()</code> are analogous to calling and returning from functions, <code>transfer()</code> works more like an unstructured goto. It lets you freely switch control between a number of fibers, all of which act as peers to one another.</p>
<p><br  />
</p><hr  />
<p> <a href="../../error-handling.html" class="right">Error Handling &rarr;</a> <a href="../../classes.html">&larr; Classes</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
