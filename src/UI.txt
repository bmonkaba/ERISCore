#include <ili9341_t3n_font_Arial.h>
#include <ili9341_t3n_font_ArialBold.h>
#include <ILI9341_t3n.h>
#include <SPIN.h>
#include "HSI.h"
#include "UI.h"
#include "ui_menu_structs.h"
#include "ui_config_strings.h" //include the autogenerated config header file; (source file is UI.json)
#include "PCA9685.h"
#include "AudioUtilities.h"

//externs
extern uint16_t control_data[4]; //global data from FATAUDIO input_adcs.cpp

//globals
ILI9341_t3n tft = ILI9341_t3n(TFT_CS, TFT_DC, TFT_RESET, TFT_MOSI, TFT_SCLK, TFT_MISO, &SPIN);
int8_t encoder1_change = 0;
int8_t encoder2_change = 0;
uint8_t last_encode1 = 0;
uint8_t last_encode2 = 0;
uint16_t FB[76800];

//ISRs
void isr_enc1_change(){
  cli();
  uint8_t encoded = ((uint8_t)digitalRead(ENC1_A_SW) << 1) | (uint8_t)digitalRead(ENC1_B_SW);
  uint8_t sum  = (last_encode1 << 2) | encoded;
  if(sum==0b1101||sum==0b0100||sum==0b0010||sum==0b1011) {encoder1_change++;}
  else if(sum==0b1110||sum==0b0111||sum==0b0001||sum==0b1000) {encoder1_change--;}
  last_encode1 = encoded;
  sei();
}

void isr_enc2_change(){
  cli();
  uint8_t encoded = ((uint8_t)digitalRead(ENC2_A_SW) << 1) | (uint8_t)digitalRead(ENC2_B_SW);
  uint8_t sum  = (last_encode2 << 2) | encoded;
  if(sum==0b1101||sum==0b0100||sum==0b0010||sum==0b1011) {encoder2_change++;}
  else if(sum==0b1110||sum==0b0111||sum==0b0001||sum==0b1000) {encoder2_change--;}
  last_encode2 = encoded;
  sei();
}

//UI class
UI::UI(){
  //load the data structs from program memory
  initUICData();
  pFB = 0;
  frame_time = millis();
  last_user_interaction_time = millis();
  update_step = 0;
  sd = 0;
  menu_count = 0;
  x = 0;
  y = 0;
  edit_mode = EDITMODE_VALUE;
  ribbon_icon_width = 0;
  ribbon_icon_height = 0;
  ribbon_display = 0;
  display_message_time = 0;
  active_menu_index = 1;
  active_control_index = 0;
  active_wallpaper_animation_frame = 0;
  encoder1_mute = 0;
  encoder2_mute = 0;
  encoder1_accel = 0;
  encoder2_accel = 0;
  encoder1_move = 0;
  encoder2_move = 0;
  encoder1_switch_pressed = 0;
  encoder2_switch_pressed = 0;
  encoder1_switch_released = 0;
  encoder2_switch_released = 0;
  encoder1_switch_state = 0;
  encoder2_switch_state = 0;
  knob1_pos_changed = 0;
  knob2_pos_changed = 0;
  knob3_pos_changed = 0;
  knob4_pos_changed = 0;
  expin_pos_changed = 0;
  fft_bins = 0;
  oscope = 0;
  menu = &ui_menus[0];
  ribbon_image_folder = &uic_ribbon_image_folder[0];
  ribbon_image = &uic_ribbon_image[0];
  ribbon_image_select_folder = &uic_ribbon_image_select_folder[0];
  ribbon_image_select = &uic_ribbon_image_select[0];
  ribbon_display = RIBBON_SHOW_TIME;
  menu_title_display = MENU_TITLE_SHOW_TIME;
  menu_title_slide_posy = 0;
  active_menu_index = 1;
  active_wallpaper_animation_frame = 0;
  fft_bins = (uint16_t *)0;
  cqt_bins = (float *)0;
  pcqt = NULL;
  encoder1_accel = 1;
  encoder2_accel = 1;
  encoder1_mute = millis();
  encoder2_mute = millis();
  spi_start_time = millis();
  level_in_r = 0;
  level_in_l = 0;
  level_out_r = 0;
  level_out_l = 0;
  //turn on backlight

  pinMode(TFT_LED_PWM, OUTPUT);
  analogWriteFrequency(TFT_LED_PWM, 42000);
  //analogWrite(TFT_LED_PWM, 4000);

  //configure encoders and setup ISRs
  pinMode(ENC1_A_SW, INPUT);
  pinMode(ENC1_B_SW, INPUT);
  pinMode(ENC2_A_SW, INPUT);
  pinMode(ENC2_B_SW, INPUT);
  pinMode(ENC1_SW, INPUT);
  pinMode(ENC2_SW, INPUT);
  attachInterrupt(ENC1_A_SW, isr_enc1_change,CHANGE);
  attachInterrupt(ENC1_B_SW, isr_enc1_change,CHANGE);
  attachInterrupt(ENC2_A_SW, isr_enc2_change,CHANGE);
  attachInterrupt(ENC2_B_SW, isr_enc2_change,CHANGE);
  return;
}

void UI::Setup(SdFatSdioEX *sdfat){
  SdFile file;
  char buf[32];
  pFB = &FB[0];
  tft.begin();
  tft.setFrameBuffer(&pFB[0]); //give a frame buffer pointer to the library
  tft.useFrameBuffer(1);
  tft.setClipRect();
  tft.setOrigin();
  tft.fillScreen(ILI9341_BLACK);
  tft.setTextColor(ILI9341_YELLOW);
  tft.setRotation(3);
  tft.updateScreen();
  //draw background
  file.open("bkgnd.ile", O_READ);
  file.fgets(buf,sizeof(buf)); // thow away these valuse - wallpaper fixed @320x240
  file.fgets(buf,sizeof(buf)); //
  for (uint32_t i = 0; i < (320 * 240); i += 1){file.read(&pFB[i],2);}
  file.close();
  tft.updateScreen();
  //analogWriteFrequency(TFT_LED_PWM, 42000);
  analogWrite(TFT_LED_PWM, 0);
  //digitalWrite(TFT_LED_PWM,0);

  sd = sdfat;
  menu_count = sizeof(uic_tab)/sizeof(uic_tab[0]);
  strcpy(buf,uic_ribbon_icon_width);
  ribbon_icon_width = atoi(buf);
  strcpy(buf,uic_ribbon_icon_height);
  ribbon_icon_height = atoi(buf);
}

UICType * UI::getpControl(const char *control_name){
  for (uint8_t i=0; i < menu_count; i++){
    for (uint8_t j=0; j < menu[i].controls_count; j++){
      if (strcmp(menu[i].controls[j].key,control_name) == 0) return &menu[i].controls[j];
    }
  }
  return (UICType *)NULL; //if control not found return null
}

UICType * UI::getpCCControl(uint8_t cc_id){
  for (uint8_t i=0; i < menu_count; i++){
    for (uint8_t j=0; j < menu[i].controls_count; j++){
      if (menu[i].controls[j].cc == cc_id) return &menu[i].controls[j];
    }
  }
  return (UICType *)NULL; //if control not found return null
}

uint16_t UI::getControlValue(const char *control_name){
  UICType * ctl;

  ctl = getpControl(control_name);
  if (ctl==NULL) return 0;
  if (ctl->mod_source == 0) ctl->mod_value = ctl->value;
  return ctl->mod_value;
}

float UI::getControlValueFloat(const char *control_name){
  UICType * ctl;

  ctl = getpControl(control_name);
  if (ctl==NULL) return 0;
  if (ctl->mod_source == 0) ctl->mod_value = ctl->value;
  return (float)ctl->mod_value / (float)ctl->max_value;
}

void UI::setControlValue(const char *control_name, uint16_t value){
  UICType * ctl;

  ctl = getpControl(control_name);
  if (ctl==NULL) return;
  if (value < ctl->min_value) value = ctl->min_value;
  if (value >= ctl->max_value) value = ctl->max_value;
  ctl->value = value;
  return;
}

void UI::setCCValue(uint8_t cc_id, uint8_t value){
  UICType * ctl;

  ctl = getpCCControl(cc_id);
  if (ctl==NULL) return;
  if (value < ctl->min_value) value = ctl->min_value;
  if (value >= ctl->max_value) value = ctl->max_value;
  ctl->value = value;
  return;
}

void UI::setControlModSource(const char *control_name,uint16_t value){
  UICType * ctl;

  ctl = getpControl(control_name);
  if (ctl==NULL) return;
  ctl->mod_source = value;
  return;
}
void UI::setControlModInvert(const char *control_name,uint16_t value){
  UICType * ctl;

  ctl = getpControl(control_name);
  if (ctl==NULL) return;
  ctl->mod_invert = value;
  return;
}

void UI::setControlModGain(const char *control_name,uint16_t value){
  UICType * ctl;

  ctl = getpControl(control_name);
  if (ctl==NULL) return;
  ctl->mod_gain = value;
  return;
}

void UI::setModulatorInput(uint8_t modulator_index, float modulator_value){
  float mv = 0; //modulated value
  //modulator range is from 0 to 1.0 values outside this range will be clamped
  if (modulator_value > 1.0) modulator_value = 1.0;if (modulator_value < 0.0) modulator_value = 0.0;
  //scan through all the controls and calculate the modulated values for each
  for (uint8_t i=0; i < menu_count; i++){
    for (uint8_t j=0; j < menu[i].controls_count; j++){
      if (menu[i].controls[j].mod_source == modulator_index){
        //calculate the modulated value (ratio)
        mv = (float)menu[i].controls[j].max_value * modulator_value; //calculate starting ratio
        mv *=(float)menu[i].controls[j].mod_gain / 50.0;   // apply gain (range from 0 to 2)
        if (menu[i].controls[j].mod_invert > 0) mv *= -1; //invert the modulator if requested
        //apply the modulator to the parameter
        mv = (float)menu[i].controls[j].value + mv;
        //clip/clamp the temp signed modulated value to the valid unsigned range of the control
        if(mv > menu[i].controls[j].max_value) mv = menu[i].controls[j].max_value;
        if(mv < menu[i].controls[j].min_value) mv = menu[i].controls[j].min_value;
        //store the value
        menu[i].controls[j].mod_value = mv;
      }
    }
  }
}

uint8_t UI::getMenuIndex(uint8_t menu_index_id){
  for (uint8_t i=0; i < menu_count; i++){
    if (menu[i].index == menu_index_id) return i;
  }
  return 0;
}

const char* UI::getActiveMenuName(){
  return menu[getMenuIndex(active_menu_index)].menu_name;
}

uint8_t UI::getUpdateStep(){
  return update_step;
}

void UI::setTapLED(bool state){
  if (state == false) setPin(I2C_LED_ADDR, I2C_LED_TAP, 0, false);
  else setPin(I2C_LED_ADDR, I2C_LED_TAP, 100, false);
}

void UI::Update()
{
  uint8_t mi;
  float fps;
  unsigned long t;
  unsigned long start_time;

  //split the screen update across multiple update calls
  //try to keep each call to under 30 msec.
  if (update_step >= 25) update_step = 1;
  start_time = micros();
  UpdateInputs();
  //Serial.println(millis() - last_user_interaction_time);
  if(millis() - last_user_interaction_time > SCREEN_SLEEP_TIME){
    //put the screen into "sleep mode"
    analogWrite(TFT_LED_PWM, 6090);
    return;
  } else analogWrite(TFT_LED_PWM, 4090);

  //encoder 1 controls the ribbon
  if (encoder1_move > 0) active_menu_index += 1;
  if (encoder1_move < 0) active_menu_index -= 1;
  if (encoder1_move != 0){
    active_control_index = 0;
    if (ribbon_display == 0) DrawWallpaperImage("bluehex.ile"); //tft.fillScreenVGradient(tft.color565(0,0,0),tft.color565(100,0,50));
    ribbon_display = RIBBON_SHOW_TIME;
    menu_title_slide_posy = 0;
    menu_title_display = MENU_TITLE_SHOW_TIME;
    edit_mode = EDITMODE_VALUE;
  }
  if (active_menu_index > menu_count){active_menu_index = 1;}
  if (active_menu_index < 1){active_menu_index = menu_count;}
  mi = getMenuIndex(active_menu_index);

  if (ribbon_display > 0) {
    tft.waitUpdateAsyncComplete();
    DrawRibbon(); //only draw the ribbon if the menu changed
    ribbon_display--;
    tft.updateScreenAsync();
    update_step = 0;
    t = millis();
    fps = 1.0 / ((float)(t - frame_time) / 1000.0);
    frame_time = t;
    return;
  }

  //update controls from inputs
  if (menu[mi].controls_count > 0){
    if(encoder1_switch_released){
      if (menu[mi].index == 8) LoadPreset();
      else if (encoder1_switch_pressed_time < 300) active_control_index += 1;
      else {
        menu[mi].controls[active_control_index].mod_source += 1;
        if (menu[mi].controls[active_control_index].mod_source > NUM_MOD_SOURCES) menu[mi].controls[active_control_index].mod_source = 0;
        //long press enc 1 - switch mod source
        switch(menu[mi].controls[active_control_index].mod_source){
          case 0:
            setDisplayMessage("Parameter Modulation Disabled");
            menu[mi].controls[active_control_index].mod_value = 0;
            break;
          case 1:
            setDisplayMessage("Parameter Modulation Source: 1"); break;
          case 2:
            setDisplayMessage("Parameter Modulation Source: 2"); break;
          case 3:
            setDisplayMessage("Parameter Modulation Source: 3"); break;
          case 4:
            setDisplayMessage("Parameter Modulation Source: 4"); break;
          default:
            setDisplayMessage("Parameter Modulation Source: UNDEFINED"); break;
        }
      }
    }
    if(encoder2_switch_released){
      if (menu[mi].index == 8) SavePreset();
      else if (encoder2_switch_pressed_time < 300) menu[mi].controls[active_control_index].value = menu[mi].controls[active_control_index].min_value;
      else {
        //long press enc2 - switch edit modes
        switch(edit_mode){
          case EDITMODE_VALUE:
            setDisplayMessage("Edit Mode: Real Time Monitor");
            edit_mode = EDITMODE_REALTIMEMONITOR; break;
          case EDITMODE_REALTIMEMONITOR:
            setDisplayMessage("Edit Mode: Modulator Gain");
            edit_mode = EDITMODE_MODGAIN; break;
          case EDITMODE_MODGAIN:
            setDisplayMessage("Edit Mode: Modulator Invert State");
            edit_mode = EDITMODE_MODINVERT; break;
          case EDITMODE_MODINVERT:
            setDisplayMessage("Edit Mode: Parameter");
            edit_mode = EDITMODE_VALUE; break;
        }
      }
    }
    if(active_control_index >= menu[mi].controls_count){active_control_index=0;}
    if (encoder2_move != 0){
      switch(edit_mode){
        case EDITMODE_REALTIMEMONITOR:
        case EDITMODE_VALUE:
          menu[mi].controls[active_control_index].value += encoder2_move;
          if(menu[mi].controls[active_control_index].value < menu[mi].controls[active_control_index].min_value){
            menu[mi].controls[active_control_index].value = menu[mi].controls[active_control_index].min_value;
          }
          else if(menu[mi].controls[active_control_index].value > menu[mi].controls[active_control_index].max_value){
            menu[mi].controls[active_control_index].value = menu[mi].controls[active_control_index].min_value;
          }
          else if(menu[mi].controls[active_control_index].value == 0  and  encoder2_move < 0 ){ //menu[mi].controls[active_control_index].min_value){
            menu[mi].controls[active_control_index].value = menu[mi].controls[active_control_index].max_value;
          }
          break;
        case EDITMODE_MODGAIN:
          menu[mi].controls[active_control_index].mod_gain += encoder2_move;
          break;
        case EDITMODE_MODINVERT:
          menu[mi].controls[active_control_index].mod_invert += encoder2_move;
          if (menu[mi].controls[active_control_index].mod_invert > 100) menu[mi].controls[active_control_index].mod_invert = 0;
          if (menu[mi].controls[active_control_index].mod_invert > 1) menu[mi].controls[active_control_index].mod_invert = 1;
          break;
      }
    }
  }
  //incremental screen update to keep the update loop time as low as reasonable
  if(update_step == 0){
  } else if (update_step == 1){
    //fps optimization - kick of the next render while the frame buffer is activly being transfered
    //calibration values are selected below to prevent the write pointer here from overrunning the DMA transfer read pointer
    if (tft.asyncUpdateActive()){
      if(strcmp(menu[mi].menu_name,"Oscilloscope")==0) return;
      if(strcmp(menu[mi].menu_name,"Spectrum")==0) return;
      if (menu[mi].controls_count%6 == 0 and millis() - spi_start_time < 30) return;
      if (menu[mi].controls_count%6 == 1 and millis() - spi_start_time < 29) return;
      if (menu[mi].controls_count%6 == 2 and millis() - spi_start_time < 28) return;
      if (menu[mi].controls_count%6 == 3 and millis() - spi_start_time < 27) return;
      if (menu[mi].controls_count%6 == 4 and millis() - spi_start_time < 27) return;
      if (menu[mi].controls_count%6 == 5 and millis() - spi_start_time < 26) return;
      if (menu[mi].controls_count%6 == 6 and millis() - spi_start_time < 25) return;
    }
  } else if (update_step == 2){
    if(strcmp(menu[mi].menu_name,"Spectrum")!=0) DrawWallpaper();
    else {
      //tft.fillScreen(0);
    }
  } else if (update_step == 3){
    if(!strcmp(menu[mi].menu_name,"Spectrum")==0) DrawLevels();
    if (menu_title_display > 0) {menu_title_display--;}
    else if (menu_title_slide_posy > -64) menu_title_slide_posy -= 3;
    if (menu_title_slide_posy > -64) DrawMenuTitle(0,menu_title_slide_posy);
    //draw display message if needed
    if(display_message_time > 0 and menu_title_display==0){
      display_message_time--;
      tft.setCursor(0,5);
      tft.setFont(MESSAGE_FONT);
      tft.setTextColor(0xFFFF,0x00000);
      tft.print(display_message_buffer);
    }
  } else if (update_step == 4){
    mi = getMenuIndex(active_menu_index);
    if(strcmp(menu[mi].menu_name,"Oscilloscope")==0) {DrawOScope();update_step = 0;tft.updateScreenAsync();}
    else if(strcmp(menu[mi].menu_name,"Spectrum")==0) {
      //DrawSpectrumAnalyzer();
      //DrawConstantQTransform();
      DrawConstantQChromagram();
      update_step = 0;
      tft.updateScreenAsync();
    }
    DrawControlsText();
  }
  if (update_step >= 4 and update_step < 25){
    //detect which "page" to render based on the active_control_index
    uint8_t page = active_control_index / 6;
    uint8_t ci = update_step - 4 + (page * 6);
    DrawControlsImg(ci); //draw control by index number (if available)
    if (ci == menu[mi].controls_count - 1 || update_step - 4 == 5){ //if all available controls have been rendered bypass any remaining control render slots
      update_step = 25;
      t = millis();
      fps = 1.0 / ((float)(t - frame_time) / 1000.0);
      frame_time = t;
      //draw fps
      tft.setCursor(280,220);
      tft.setFont(FPS_FONT);
      tft.setTextColor(tft.color565(255,255,255),tft.color565(50,0,0));
      tft.print(fps);
      if (!tft.asyncUpdateActive()) {tft.updateScreenAsync();spi_start_time = millis();}
    } else if (update_step == 6) {tft.updateScreenAsync(); spi_start_time = millis();}//kick off the screen update early
  }

  if (update_step == 25){
    //FREE STEP
  }
  update_step++;
}

void UI::DrawMenuTitle(int16_t x,int16_t y){
  char buf[24];
  snprintf(buf, 24, "t%d.ile",active_menu_index);
  blt("/A/I/U/T",buf,x,y-8,AT_HATCHBLK);
}

void UI::DrawControlsText(){
  uint8_t page = active_control_index/6;
  uint8_t mi = getMenuIndex(active_menu_index);
  for (int ci = page * 6; ci < menu[mi].controls_count && ci < (page*6) + 6; ci++){
    int16_t x = 0;
    int16_t y = 0;
    tft.setCursor(menu[mi].controls[ci].x,menu[mi].controls[ci].y);
    tft.setFont(CONTROL_FONT);
    if (active_control_index == ci)tft.setTextColor(0xFFFF,tft.color565(200,0,100)); //highlight active control
    else tft.setTextColor(0xFFFF,0x00000);
    tft.print(menu[mi].controls[ci].text);
    tft.getCursor(&x,&y);
    //center the image below the text
    x = menu[mi].controls[ci].x ;//+ (x - menu[mi].controls[ci].x)/2 - CONTROL_IMAGE_WIDTH/2;
    y = menu[mi].controls[ci].y + CONTROL_FONT_SIZE + 10;
    //if (active_control_index == ci) tft.fillCircle(x+32, y+32, 25,tft.color565(80,0,15));
    switch(menu[mi].controls[ci].mod_source){
      case 0:
        tft.fillCircle(x+32, y+32, 17,tft.color565(64,64,64));
        tft.fillCircle(x+32, y+32, 13,tft.color565(0,0,0));
        break;
      case 1:
        tft.fillCircle(x+32, y+32, 17,tft.color565(255,224,25));
        tft.fillCircle(x+32, y+32, 13,tft.color565(75,66,9));
        break;
      case 2:
        tft.fillCircle(x+32, y+32, 17,tft.color565(0,214,128));
        tft.fillCircle(x+32, y+32, 13,tft.color565(0,63,39));
        break;
      case 3:
        tft.fillCircle(x+32, y+32, 17,tft.color565(47,255,18));
        tft.fillCircle(x+32, y+32, 13,tft.color565(15,65,6));
        break;
      case 4:
        tft.fillCircle(x+32, y+32, 17,tft.color565(255,255,255));
        tft.fillCircle(x+32, y+32, 13,tft.color565(75,75,75));
        break;
      default: //should not reach
        tft.fillCircle(x+32, y+32, 17,tft.color565(255,255,255));
        break;
    }
  }
}

void UI::DrawControlsImg(uint8_t control_index){
  uint8_t mi = getMenuIndex(active_menu_index);
  if (menu[mi].controls_count == 0 ) return;
  else if (control_index > menu[mi].controls_count -1) return;
  uint8_t ci = control_index;
  int16_t x = 0;
  int16_t y = 0;
  char buf[24];
  x = menu[mi].controls[ci].x ;//+ (x - menu[mi].controls[ci].x)/2 - CONTROL_IMAGE_WIDTH/2;
  y = menu[mi].controls[ci].y + CONTROL_FONT_SIZE + 10;
 switch(edit_mode){ //swith theme depending on edit mode
    case EDITMODE_REALTIMEMONITOR: //magenta
      snprintf(buf, 24, "single_%02d.ile", menu[mi].controls[ci].mod_value);
      blt(menu[mi].controls[ci].path_1,buf,x,y,AT_TRANS);
      break;
    case EDITMODE_VALUE: //green
      snprintf(buf, 24, "single_%02d.ile", int(100 * (menu[mi].controls[ci].value - menu[mi].controls[ci].min_value)/(menu[mi].controls[ci].max_value - menu[mi].controls[ci].min_value)));
      blt(menu[mi].controls[ci].path_2,buf,x,y,AT_TRANS);
      break;
    case EDITMODE_MODGAIN: ///teal
      snprintf(buf, 24, "single_%02d.ile", menu[mi].controls[ci].mod_gain);
      blt(menu[mi].controls[ci].path_3,buf,x,y,AT_TRANS);
      break;
    case EDITMODE_MODINVERT: //yellow
      snprintf(buf, 24, "single_%02d.ile", menu[mi].controls[ci].mod_invert);
      blt(menu[mi].controls[ci].path_4,buf,x,y,AT_TRANS);
      break;
    default:
      snprintf(buf, 24, "single_%02d.ile", int(100 * (menu[mi].controls[ci].value - menu[mi].controls[ci].min_value)/(menu[mi].controls[ci].max_value - menu[mi].controls[ci].min_value)));
      blt(menu[mi].controls[ci].path_1,buf,x,y,AT_TRANS);
  }
}


void UI::DrawRibbon(){
    uint8_t mi = getMenuIndex(active_menu_index);
    int offset_x = (menu[mi].index) * -1 * ribbon_icon_width - 2;
    blt(ribbon_image_folder,ribbon_image,offset_x,0,AT_NONE); //center ribbon then negitive offset by index
    blt(ribbon_image_select_folder,ribbon_image_select,ribbon_icon_width * 2,0,AT_TRANS); //center ribbon then negitive offset by index
}
void UI::DrawWallpaper(){
  //full screen block transfer with no clipping - used for full screen images matching the screen resolution
  SdFile file;
  char buf[8];
  active_wallpaper_animation_frame += 1;
  snprintf(buf, 8, "%03d.ile", active_wallpaper_animation_frame);
  sd->chdir(menu[getMenuIndex(active_menu_index)].wallpaper);
  file.open(buf, O_READ);
  if (file.available() == 0){ //end of animation - loop from begining frame
    active_wallpaper_animation_frame = 0;
    snprintf(buf, 8, "%03d.ile", active_wallpaper_animation_frame);
    file.open(buf, O_READ);
  }
  file.seekSet(15); //skip the header - header will always be 15 bytes for full screen wallpaper
  //for (unsigned long i = (320 * 64) ; i < (320 * 240); i += 32){
  for (unsigned long i = 0; i < (320 * 240); i += 4096){ //32,64
    file.read(&pFB[i],8192);
  }
  file.close();
}

void UI::DrawWallpaperImage(char *filename){
  //full screen block transfer with no clipping - used for full screen images matching the screen resolution
  SdFile file;
  sd->chdir("/A/I/U/W");
  file.open(filename, O_READ);
  if (file.available() == 0){ //file not found
    return;
  }
  file.seekSet(15); //skip the header - header will always be 15 bytes for full screen wallpaper
  //for (unsigned long i = (320 * 64) ; i < (320 * 240); i += 32){
  for (unsigned long i = 0; i < (320 * 240); i += 1024){ //32,64
    file.read(&pFB[i],2048);
  }
  file.close();
}

void UI::blt(const char *p, const char *f,int16_t x,int16_t y,UIBLTAlphaType alpha_type){
  SdFile file;
  int16_t iy; // x & y index
  int16_t w;int16_t h; //width & height
  int16_t mx;        //left clip x offset
  int16_t nx;        //right clip x offset
  unsigned long ifb; //frame buffer index
  uint16_t dwbf[320];//file read pixel row input buffer
  uint16_t dw;       //pixel data
  char str[16];      //char buffer
  char *c;           //char pointer
  bool toggle = false;
  sd->chdir(p);                //change file path
  file.open(f, O_READ);        //open image to read
  file.fgets(str,sizeof(str)); //read the header data
  file.fgets(str,sizeof(str)); //to get the image dimensions
  strtok(str," ");             //convert dimension text to numbers
  w = atol(str);
  c = strtok(NULL, " ");
  h = atol(c);
  //clip in y dimension (top)
  if (y<0) { //throw away rows which are off screen
    for (iy = 0; iy < -1L * y; iy += 1L){ //for each off screen row
      file.seekCur(w*2L);
      h -= 1; //reduce bitmap hight by 1 row
    }
    y = 0; //set y pos to 0 for the remaining portion of the bitmap
  }
  for (iy = y; iy < y + h; iy += 1){ //for each row
    toggle ^= true;
    if (iy < 240L) //clip in y dimension (bottom) - simply don't draw anything
    {
      mx = 0; nx = 0;
      if (x < 0L){file.seekCur(x * -2L);mx = -1L * x;} //clip in x dimension (left) - skip offscreen data
      ifb = (iy * 320L) + x + mx; //32bit index
      if (x + w > 320L){nx = x + w - 320L;}//clip in x dimension (right) - truncate copy to screen bounds
      for (uint16_t z = 0; z < (w - mx - nx); z += 1){
        //debug - testing performance increase of reading an entire row of img data at once
        if ((w - mx - nx)<= 320){
          if (z == 0) file.read(&dwbf,(w - mx - nx)*2);
          dw = dwbf[z];
        } else file.read(&dw,2); //should never execute...but just in case

        toggle ^= true;
        //if alpha is enabled mask any colors close to black
        if (alpha_type == AT_NONE){pFB[ifb + z] = dw;}
        else if (alpha_type == AT_TRANS && (dw & 0xE79C) != 0){pFB[ifb + z] = dw;}
        else if (alpha_type == AT_HATCHBLK){
          if ((dw & 0xE79C) != 0) pFB[ifb + z] = dw;
          else if (toggle) pFB[ifb + z] = 0; //pFB[i] ^= pFB[i];
        }
        else if (alpha_type == AT_HATCHXOR){
          if ((dw & 0xE79C) != 0) pFB[ifb + z] = dw;
          else if (toggle) pFB[ifb + z] = pFB[ifb + z]^pFB[ifb + z];
        }
      }
      if (x + w > 320L){file.seekCur( (x + w - 320L) * 2);} //clip in x dimension (right) - skip unused data away
    }
    else{
      //since y index is now off screen close the file and return
      file.close();
      return;
    }
  }
  file.close();
}

void UI::setpFFT(uint16_t *fft_bin_array){
  fft_bins = fft_bin_array;
}

void UI::setpCQT(CQT *p_cqt){
  pcqt = p_cqt;
  cqt_bins = pcqt->cqt;
}

void UI::setpScope(int16_t *oscope_array){
  oscope = oscope_array;
}

void UI::DrawScreenDoor(uint16_t y,uint16_t h){
  bool toggle = false;
  for(int16_t i = y * 320; i < (y + h) * 320; i ++){
    if (i%320 == 0)toggle ^= true;//extra toggle per line to create a cross hatch pattern instead of verticle lines
    toggle ^= true;
    if (toggle) pFB[i] = 0; //pFB[i] ^= pFB[i];
  }
}

void UI::DrawOScope(){
  if(&oscope[0] == 0){Serial.println("UI::DrawOScope buffer is null");return;}
  for(int16_t i = 0 ; i < 319; i ++){
    int16_t y;
    y = oscope[i];
    //Serial.println(y);
    if (y < 0) y = 0; if (y > 314) y = 314;
    tft.drawPixel(i,y++, tft.color565(0,0,0));
    tft.drawPixel(i+1,y, tft.color565(0,0,0));
    tft.drawPixel(i,y++, tft.color565(0,255,0));
    tft.drawPixel(i+1,y, tft.color565(0,0,0));
    tft.drawPixel(i,y++, tft.color565(0,255,128));
    tft.drawPixel(i+1,y, tft.color565(0,0,0));
    tft.drawPixel(i,y++, tft.color565(0,128,255));
    tft.drawPixel(i+1,y, tft.color565(0,0,0));
    tft.drawPixel(i,y++, tft.color565(128,255,128));
    tft.drawPixel(i+1,y, tft.color565(0,0,0));
    tft.drawPixel(i,y++, tft.color565(255,255,128));
    tft.drawPixel(i+1,y, tft.color565(0,0,0));
  }
}

void UI::DrawLevels(){
  //clamp max value to 1
  if(level_in_r > 1.0) level_in_r = 1.0;
  if(level_in_l > 1.0) level_in_l = 1.0;
  if(level_out_r > 1.0) level_out_r = 1.0;
  if(level_out_l > 1.0) level_out_l = 1.0;
  //draw level meters
  tft.fillRectVGradient(0,240-(176*level_in_r),8,176*level_in_r, tft.color565(232,0,30),tft.color565(0,230,80));
  tft.fillRectVGradient(10,240-(176*level_in_l),8,176*level_in_l, tft.color565(232,0,30),tft.color565(0,230,80));
  tft.fillRectVGradient(320-20,240-(176*level_out_r),8,176*level_out_r, tft.color565(232,0,30),tft.color565(0,230,80));
  tft.fillRectVGradient(320-10,240-(176*level_out_l),8,176*level_out_l, tft.color565(232,0,30),tft.color565(0,230,80));
}

void UI::DrawSpectrumAnalyzer(){
  if(&fft_bins[0] == 0){Serial.println("UI::DrawSpectrumAnalyzer bin memory not initialized");return;}
  for (uint16_t x = 5;x <= 315/4;x +=1){
     //zoom fft x axis by 4 to focus on guitar freq range
     uint8_t h;
     h = (250*(fft_bins[x]  * (1.0 / 1000.0)));
     tft.fillRect(x*4,240-h,5,h, 0x0000);//
     tft.fillRectVGradient(x*4,240-h,3,h, tft.color565(255,0,116),tft.color565(0,190,130));//
  }
}

#define DISP_CQT_STARTING_BIN 7

void UI::DrawConstantQChromagram(){
  if(&cqt_bins[0] == 0){Serial.println("UI::DrawConstantQChromagram bin memory not initialized");return;}
  unsigned long ifb;
  uint8_t display_height = 120;

  //first shift screen pixels right on the bottom half of the screen
  for (ifb = 320*240; ifb > 320*240 / 2; ifb -=1) pFB[ifb] = pFB[ifb-1];
  //draw cqt in the first column of pixels
  for (uint16_t x = 0; x < 61; x +=1){
      int8_t r,g,b;
      int8_t i = 60-x;
      r = (int8_t)(cqt_bins[i]* 80);
      g = (int8_t)(cqt_bins[i]* 80);
      b = (int8_t)(cqt_bins[i]* 80);
      if (cqt_bins[i] > 0.20) g = (int8_t)(cqt_bins[i]* 255);
      if  (cqt_bins[i] > 0.46) {b = (int8_t)(cqt_bins[i]* 255);r=b;g=b;}

      tft.drawPixel(0,(x*2) - 2 + display_height,tft.color565(r,g,b));
      tft.drawPixel(0,(x*2) - 1 + display_height,tft.color565(r,g,b));
      tft.drawPixel(0,(x*2) - 0 + display_height,tft.color565(r,g,b));
  }

  // draw the synth oscillator in a different color
  for(int8_t index = 0; index < SYNTH_VOICES_COUNT;index+=1){
    x = 60 - pcqt->fantb[index].b;
    tft.drawPixel(0,(x*2) - 2 + display_height,tft.color565(255,0,0));
  }

  //draw the state pixel
  switch (pcqt->state){
    case CQT_HOLDOFF:
      tft.drawPixel(0,239,tft.color565(255,0,255));
      break;
    case CQT_SAMPLING:
      tft.drawPixel(0,239,tft.color565(0,255,0));
      break;
    case CQT_HOLD:
      tft.drawPixel(0,239,tft.color565(255,0,0));
      break;
  }

  DrawConstantQTransform();  
}

void UI::DrawConstantQTransform(){
  uint8_t display_height = 120;

  if(&cqt_bins[0] == 0){Serial.println("UI::DrawConstantQTransform bin memory not initialized");return;}
/*

    //draw the peak line
  tft.fillRect((pcqt->peak_bin)* 6 ,0,10,display_height-(int)(pcqt->peak_value * display_height) - 5, tft.color565(0,0,0));
  tft.fillRect((pcqt->peak_bin)* 6 ,0,5,display_height-(int)(pcqt->peak_value * display_height) - 5, tft.color565(80,80,255));
  //draw the octave line
  //tft.fillRect((pcqt->peak_bin + 12)*6,0,10,display_height-(int)(pcqt->peak_value * display_height) - 5, tft.color565(0,0,0));
  //tft.fillRect((pcqt->peak_bin + 12)*6,0,5,display_height-(int)(pcqt->peak_value * display_height) - 5, tft.color565(80,80,180));
  //draw the 3rd line
  if (1 || pcqt->chord_quality == 3){
    tft.fillRect((pcqt->peak_bin + 3 + 12)*6,0,6,display_height-(int)(pcqt->peak_value * display_height) - 5, tft.color565(0,0,0));
    tft.fillRect((pcqt->peak_bin + 3 + 12)*6,0,2,display_height-(int)(pcqt->peak_value * display_height) - 5, tft.color565(255,0,0));
  }
  //draw the 4th line
  if (1 || pcqt->chord_quality == 4){
    tft.fillRect((pcqt->peak_bin + 4 + 12)*6,0,6,display_height-(int)(pcqt->peak_value * display_height) - 5, tft.color565(0,0,0));
    tft.fillRect((pcqt->peak_bin + 4 + 12)*6,0,2,display_height-(int)(pcqt->peak_value * display_height) - 5, tft.color565(0,180,120));
  }
  //draw the 7th line
  tft.fillRect((pcqt->peak_bin + 7 + 12)*6,0,6,display_height-(int)(pcqt->peak_value * display_height) - 5, tft.color565(0,0,0));
  tft.fillRect((pcqt->peak_bin + 7 + 12)*6,0,2,display_height-(int)(pcqt->peak_value * display_height) - 5, tft.color565(255,255,0));
*/



//clear the portion of the screen for rendering the q transform
  //tft.fillRectVGradient(0,0,320,120, tft.color565(0,0,0),tft.color565(64,0,32));
  //TODO -  add persistance
  int16_t x,y,offset;
  int16_t red_mask = 0xF800;
  int16_t green_mask = 0x7E0;
  int16_t blue_mask = 0x1F;
  uint8_t red;
  uint8_t green;
  uint8_t blue;
  uint16_t pixel;

  for (x = 0;x < 320; x++){
    for(y=0;y < 118;y++){
      //unpack the 565 color pixel and convert to an 8bit value
      //when adding/subtracting take notice of the lost least significant bits
      //this establishes the min step of 8 when working with 8bit color component values   

      if (y%2==0) {offset = 1;//(int16_t)(0.0002*((y+10)^2)-(0.0505*(y+10))+3.8644);
      }
      else {offset = 0;}

      if ((x - offset) > 0) {
        pixel = pFB[((y+1) * 320) + x - offset]; //source
        red = (pixel & red_mask) >> 11; //unpack
        red = red << 3; //convert
        green = (pixel & green_mask) >> 5;
        green = green << 2;
        blue = (pixel & blue_mask);
        blue = blue << 3;

        if (red > 80){red-=10;}
        if (green > 80){green-=24;}
        if (blue > 80){blue-=10;}

        if (red > 1 && y%12 == 0){red-=1;}
        if (green > 1 && y%4 == 0){green-=1;}
        if (blue > 1 && y%12 == 0){blue-=1;}
        //if (red <= 2 || green <= 10 || blue <= 10){red=0;green=0;blue=0;}
        
        pixel = ((red << 8) & red_mask) | ((green << 3) & green_mask) | ((blue >> 3) & blue_mask);
        pFB[x + (y * 320)] = pixel; //destination
      } else{
        //testing - highlight outside area in RED
        red = 80; green = 80; blue = 80;
        pixel = ((red << 8) & red_mask) | ((green << 3) & green_mask) | ((blue >> 3) & blue_mask);
        pFB[x + (y * 320)] = pixel;
      }      
    }
  }



  for (uint16_t x = DISP_CQT_STARTING_BIN; x <= DISP_CQT_STARTING_BIN + 54; x +=1){
     uint8_t h;
     float fh;
     uint8_t shadow_h;
     fh = cqt_bins[x];
     h = (int)(display_height * fh);
     shadow_h = h + 5;
     if (shadow_h >= display_height) shadow_h = h;

     //if((x-DISP_CQT_STARTING_BIN)%12==0) tft.fillRect((x-DISP_CQT_STARTING_BIN)*6,0,3,display_height, tft.color565(32,32,32));
     //tft.fillRect((x-DISP_CQT_STARTING_BIN)*6,display_height-shadow_h,4,shadow_h, tft.color565(255,190,255));//
     if ((x)%12 == (pcqt->cqt_peak_bin)%12){
      tft.fillRectVGradient((x)*6,display_height-h,4,h, tft.color565(255,255,255),tft.color565(50,50,50));//
     }
     else if ((x)%12 == (pcqt->cqt_peak_bin + 3 + 12)%12 && pcqt->chord_quality >= 7){
      tft.fillRectVGradient((x)*6,display_height-h,4,h, tft.color565(0, 0, 255),tft.color565(0, 0, 50));//minor
     }
     else if ((x)%12 == (pcqt->cqt_peak_bin + 4 + 12)%12 && pcqt->chord_quality < 7){
      tft.fillRectVGradient((x)*6,display_height-h,4,h, tft.color565(0,255,0),tft.color565(0,50,0));//major
     }
     else if ((x)%12 == (pcqt->cqt_peak_bin + 7 + 12)%12){
      tft.fillRectVGradient((x)*6,display_height-h,4,h, tft.color565(255,0,0),tft.color565(50,0,0));//perfect fifth
     }
     
     else{
      //tft.fillRectVGradient((x)*6,display_height-h,4,h, tft.color565(60,60,60),tft.color565(20,0,20));//
     }
     
  }


  


  //display the note and chord (if available)
  tft.setCursor(10,0);//(((pcqt->peak_bin)*6),0);
  tft.setFont(CQT_FONT);
  tft.setTextColor(tft.color565(255,255,255),tft.color565(0,0,0));
  if (strcmp(nn(pcqt->cqt_peak_bin),"NONE") != 0) tft.print(nn(pcqt->cqt_peak_bin + 24 - 5)); //peak bin starts at the 2nd octave.
  tft.print(pcqt->cq_label[pcqt->chord_quality]);

}

void UI::UpdateInputs(){
  int8_t sw;
  //Get encoder switch states
  encoder1_switch_released = 0;
  encoder2_switch_released = 0;
  sw = digitalRead(ENC1_SW);
  if(sw == 0 and encoder1_switch_state == 1){encoder1_switch_released = 1; encoder1_switch_pressed_time = millis() - encoder1_switch_press_time;}
  encoder1_switch_pressed = 0;
  if(sw == 1 and encoder1_switch_state == 0){encoder1_switch_pressed = 1; encoder1_switch_press_time = millis();}
  encoder1_switch_state = sw;

  sw = digitalRead(ENC2_SW);
  if(sw == 0 and encoder2_switch_state == 1){encoder2_switch_released = 1;encoder2_switch_pressed_time = millis() - encoder2_switch_press_time;}
  encoder2_switch_pressed = 0;
  if(sw == 1 and encoder2_switch_state == 0){encoder2_switch_pressed = 1; encoder2_switch_press_time = millis();}
  encoder2_switch_state = sw;

  //Get encoder movement (w/ integrated acceleration)
  encoder1_move = 0; encoder2_move = 0;

  if(millis() - encoder1_mute >= UI_ENCODER_MUTE_TIME){
    encoder1_mute = millis();
    if (encoder1_change > 0){
      if (encoder1_accel < 1) encoder1_accel = 1;
      encoder1_move += 1 * encoder1_accel;
      encoder1_accel += 1;
    } else if (encoder1_change <0){
      if (encoder1_accel > -1) encoder1_accel = -1;
      encoder1_move -= 1 * abs(encoder1_accel);
      encoder1_accel -= 1;
    } else if (encoder1_accel > 1){
      encoder1_accel-=1;
      if(encoder1_accel>ENC_ACCEL) encoder1_accel=ENC_ACCEL;
    } else if (encoder1_accel < -1){
      encoder1_accel+=1;
      if(abs(encoder1_accel)>ENC_ACCEL) encoder1_accel= -1 * ENC_ACCEL;
    }
  }
  //special case for encoder 1 - clamp small accerations to one movement at a time.
  //used for smooth menu navigation
  if (encoder1_move == 1) encoder1_move = 0;
  if (encoder1_move == -1) encoder1_move = 0;
  if (encoder1_move > -3 && encoder1_move < 3) encoder1_move /= abs(encoder1_move);


  if(millis() - encoder2_mute >= UI_ENCODER_MUTE_TIME){
    encoder2_mute = millis();
    if (encoder2_change > 0){
      if (encoder2_accel < 1) encoder2_accel = 1;
      encoder2_move += 1 * encoder2_accel;
      encoder2_accel += 1;
    } else if (encoder2_change <0){
      if (encoder2_accel > -1) encoder2_accel = -1;
      encoder2_move -= 1 * abs(encoder2_accel);
      encoder2_accel -= 1;
    } else if (encoder2_accel > 1){
      encoder2_accel-=1;
      if(encoder2_accel>ENC_ACCEL) encoder2_accel=ENC_ACCEL;
    } else if (encoder2_accel < -1){
      encoder2_accel+=1;
      if(abs(encoder2_accel)>ENC_ACCEL) encoder2_accel= -1 * ENC_ACCEL;
    }
  }


  //Read the analog inputs
  uint16_t atmp;
  atmp = analogRead(AN1) >> 6;
  if (atmp != knob1_pos){knob1_pos_changed = 1;knob1_pos = atmp;} else{knob1_pos_changed = 0;}
  atmp = analogRead(AN2) >> 6;
  if (atmp != knob2_pos){knob2_pos_changed = 1;knob2_pos = atmp;} else{knob2_pos_changed = 0;}
  atmp = analogRead(AN3) >> 6;
  if (atmp != knob3_pos){knob3_pos_changed = 1;knob3_pos = atmp;} else{knob3_pos_changed = 0;}
  atmp = analogRead(AN4) >> 6;
  if (atmp != knob4_pos){knob4_pos_changed = 1;knob4_pos = atmp;} else{knob4_pos_changed = 0;}
  atmp = analogRead(EXP_IN);
  if (atmp != expin_pos){expin_pos_changed = 1;expin_pos = atmp;} else{expin_pos_changed = 0;}

  if(encoder1_change || encoder2_change || encoder1_switch_pressed || encoder1_switch_released \
    || encoder2_switch_pressed ||encoder2_switch_released ){last_user_interaction_time = millis();}

    //|| knob1_pos_changed || knob2_pos_changed \
    //|| knob3_pos_changed || knob4_pos_changed

  //clear the flags set by the ISR
  encoder1_change = 0;
  encoder2_change = 0;
}

void None(){};

void UI::setDisplayMessageWithValue(char *message,uint16_t value){
  snprintf(display_message_buffer, 64, "%s : %03d", message, value);
  display_message_time = MESSAGE_SHOW_TIME;
}
void UI::setDisplayMessage(char *message){
  strcpy(display_message_buffer,message);
  display_message_time = MESSAGE_SHOW_TIME;
}

void UI::SavePreset(){
  SdFile file;
  uint16_t index = getControlValue("preset_index");
  char cbuffer[128];
  snprintf(cbuffer, 128, "preset_%03d.txt", index);
  Serial.println("Preset Save");
  Serial.println(cbuffer);
  sd->chdir("/A/PRESETS");//change file path
  file.open(cbuffer, O_CREAT | O_WRITE);       //open file to write
  //traverse the controls and save all label and value pairs
  for (uint8_t i=0; i < menu_count; i++){
    for (uint8_t j=0; j < menu[i].controls_count; j++){
        file.write(menu[i].controls[j].key);file.write(",");
        sprintf(cbuffer, "%d", menu[i].controls[j].value);
        file.write(cbuffer);file.write(",");
        sprintf(cbuffer, "%d", menu[i].controls[j].mod_source);
        file.write(cbuffer);file.write(",");
        sprintf(cbuffer, "%d", menu[i].controls[j].mod_invert);
        file.write(cbuffer);file.write(",");
        sprintf(cbuffer, "%d\n", menu[i].controls[j].mod_gain);
        file.write(cbuffer);file.write(",");
        file.flush();
    }
  }
  file.close();
  setDisplayMessageWithValue("Saved Preset ",index);
}

void UI::LoadPreset(){
  SdFile file;
  uint16_t index = getControlValue("preset_index");
  char cbuffer[128];
  int n;
  char *control_name;
  char *control_value_string;
  uint16_t value;

  snprintf(cbuffer, 128, "preset_%03d.txt", index);
  sd->chdir("/A/PRESETS");//change file path
  file.open(cbuffer, O_READ);       //open file to read
  while ((n = file.fgets(cbuffer, 128)) > 0)
  {
    control_name = strtok(cbuffer, ",");
    control_value_string = strtok(NULL, ",");
    value = (uint16_t) strtol(control_value_string, NULL, 10);
    setControlValue(control_name, value);
    control_value_string = strtok(NULL, ",");
    value = (uint16_t) strtol(control_value_string, NULL, 10);
    setControlModSource(control_name, value);
    control_value_string = strtok(NULL, ",");
    value = (uint16_t) strtol(control_value_string, NULL, 10);
    setControlModInvert(control_name, value);
    control_value_string = strtok(NULL, ",");
    value = (uint16_t) strtol(control_value_string, NULL, 10);
    setControlModGain(control_name, value);
  }
  setDisplayMessageWithValue("Loaded Preset ",index);
  file.close();
}
