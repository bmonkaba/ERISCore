import os
from PIL import Image, ImageDraw,ImageFont
from array import array
import json

  

TEXT_FONT_SIZE = 36

#convert 8 bit r,g,b values into 16 bit 565 format 
def color565(r,g,b):
    return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);

 
#create a 565 packed bitmap stream file 
#from a bin  ppm file exported from gimp
def Gen565Stream(in_file,out_file):
    in_data = array('B')    
    with open(in_file, 'rb') as f:
        #print in_file        
        f.readline() #magic
        l = f.readline() #may contain gimp comment
        if (l[0] == "#"): #if comment get next line (dimensions)
            dim = f.readline() #
        else:               #if not a comment then this line is the dimensions
            dim = l
        #print 
        bits = f.readline() #get bit depth
        #print bits
        x = int(dim.split(' ')[0])
        y = int(dim.split(' ')[1])
        in_data.fromfile(f,x*y*3)     #read 8 bit (R,G,B) per pixel data in
    out_data = array("H",[0] * x*y)       #create a 16 bit output array
    #print len(in_data), x * y * 3
    for i in range(0,len(in_data),3):
        r = in_data[i]  #R       B
        g = in_data[i + 1] #G    R
        b = in_data[i + 2] #B    G
        out_data[i/3] = color565(r,g,b)
    with open(out_file, 'wb') as f:
        f.write('ILE565\n') #image little endian 565 formated data
        f.write(dim)      #width height dimensions      
        f.write(out_data) #565 packed data 
    #print len(out_data), x * y
    #print str(out_data[1])
    return


def GenTextTag(text,out_file,font_size=64):
    print (text + " " + out_file)
    img = Image.new('RGB', (320, font_size), color = (0, 0, 0))    
    fnt = ImageFont.truetype('C:\\Windows\\FontsFonts\\heavy_data.ttf', font_size)    
    d = ImageDraw.Draw(img)
    d.text((0,0), text, font=fnt, fill=(255,255,255))
    img.save(out_file)
    return
    
if __name__ == "__main__":
    #create number text tags for the UI
    for i in range(0,300):    
        GenTextTag(str(i),".\\A\\I\\U\\N\\single_%02d.png"%i)
    
    
    #deconstruct UI.json file into individual components
    #and create an arduino string file 
    ard = ""
    ard_array = "const char* uic_tab[] = {"    
    f = open(".\\A\\I\\U\\UI.json")    
    j = json.loads(f.read())
    f.close()
    for key in j.keys():
        fn = ".\\A\\I\\U\\J\\" + key + ".json"
        print ("Generating " + fn)
        f = open(fn,"w")
        f.write(json.dumps(j[key]))
        f.close()
        if(json.dumps(j[key]).find("}") > -1):
            frmt = json.dumps(j[key]).replace('"',"\\'").replace("'",'"')
        else:
            frmt = json.dumps(j[key]).replace('"',"")
        ard += "const char* PROGMEM uic_"+key + " = \"" + frmt + "\";\n"
        if (key[0] == 't'):
            ard_array += "uic_" + key + ", "
            
        ##make the bitmap description text tag from [key].description            
        #size is 16x320

        if str(j[key]).find('description')>0:
            print("OK")
            #k = json.loads(str(j[key]))
            if j[key].has_key('menu_name'):
                print( "Generating text tag for " + key)
                GenTextTag(j[key]['menu_name'],".\\A\\I\\U\\T\\" + key + ".png",TEXT_FONT_SIZE)    
        
    f = open(".\\ERIS\\ui_config_strings.h","w")
    f.write(ard + ard_array[:-2] + '};\n')
    f.close()
    #create const file for all data
    exclude = """
    init_buffer = "\n\n//init UIC data structs\nvoid initUICData(){\n"
    f = open(".\\ERIS\\ui_menu_structs.h","w")
    f.write("// Autogenerated code from an ERIS python tool script\n\n")
    f.write("//Call initUICData() to load the data into the ui_menus[] structure array")
    f.write("//\n")
    menus = []    
    for i in range(1,j["menu_count"]+1):
        t = j["t"+str(i)]
        m = "t"+str(i)
        f.write("UIMenuType " + m + ";\n")
        menus.append(m)
        for key in t.keys():
            #f.write(key + ":" +str(type(t[key])) + "\n")
            v = key.replace(" ","_")
            if type(t[key]) == int:
                f.write("const uint8_t PROGMEM t"+str(i) + "_" + v + " = " + str(t[key]) + ";\n")
                init_buffer += "\t"+m + "." + v + " = " + m + "_" + v + ";\n"
            elif type(t[key]) == float:
                f.write("const float PROGMEM t"+str(i) + "_" + v + " = " + str(t[key]) + ";\n") 
                init_buffer += "\t"+m + "." + v + " = " + m + "_" + v + ";\n"
            elif  type(t[key]) != dict:#string
                f.write("const char* PROGMEM t"+str(i) + "_" + v + " = \"" + str(t[key]) + "\";\n")
                init_buffer += "\t"+m + "." + v + " = &" + m + "_" + v + "[0];\n"
            else: #dict
                #this is the controls dict
                f.write("const uint8_t PROGMEM t"+str(i) + "_" + "controls_count" + " =  "+ str(t[key]["controls_count"]) + ";\n")
                init_buffer += "\t"+m + ".controls_count = " + m + "_" + "controls_count;\n"               
                init_buffer += "\t"+m + ".controls = &" + m + "_" + "controls[0];\n"                 
                #for each
                controls = []
                for k in range(1,t[key]["controls_count"]+1): #controls
                    cid = "t"+str(i) +"_" + "c" + str(k)
                    controls.append(cid)
                    f.write("UICType " + cid + ";\n")                
                    c = t[key]["c"+str(k)]
                    for subkey in c.keys():
                        v = subkey.replace(" ","_")
                        if type(c[subkey]) == int:
                            if (v != 'x' and v != 'y'):
                                f.write("const uint8_t PROGMEM "+cid+"_"+ v + " = " + str(c[subkey]) + ";\n")
                            else:
                                f.write("const uint16_t PROGMEM "+cid+"_"+ v + " = " + str(c[subkey]) + ";\n")                                
                            init_buffer += "\t"+cid + "." + v + " = " + cid+"_"+ subkey + ";\n"
                        elif type(c[subkey]) == float:
                            f.write("const float PROGMEM "+cid+"_"+v + " = " + str(c[subkey]) + ";\n")
                            init_buffer += "\t"+cid + "." + v + " = " + cid+"_"+ v + ";\n"
                        elif type(c[subkey]) != dict:#string
                            #print subkey,c[subkey],type(c[subkey])
                            f.write("const char* PROGMEM "+cid+"_"+ v + " = \"" + str(c[subkey]) + "\";\n")
                            init_buffer += "\t"+cid + "." + v + " = &" + cid+"_"+ v + "[0];\n"
                #controls = "[&" + ",&".join(map(str,controls)) + "]"
                f.write("UICType " + m + "_controls[] = "+ str(controls).replace('[','{').replace(']','}').replace("'","")+";\n")
    #menus = "[&" + ",&".join(map(str,menus)) + "]"
    f.write("UIMenuType ui_menus[] = "+ str(menus).replace('[','{').replace(']','}').replace("'","")+";\n")
    f.write(init_buffer + "}\n")
    f.close()
    """
    
    #
    # Convert png graphics to ile (inline 565 bitmap encoding)
    #
    dstruct = {}    
    for root, directory, files in os.walk(".\\A\\"):
        #for d in directory:
        for f in files:
            fp = root + "\\" + f
            if fp[-4:] == ".png":
                print (fp)
                ppm = fp[:-4] + ".ppm"
                ile = fp[:-4] + ".ile"
                #batch convert images with PIL
                if fp.find("\\V\\") > -1:
                    img_index = f.split("_")[1]
                    while(len(img_index) < 3):
                        img_index = "0" + img_index 
                        
                    ile = root + "\\" + img_index + ".ile"
                    size = 320,240
                    if dstruct.has_key(root) == True:
                        dstruct[root] = dstruct[root] + 1
                    else:
                        dstruct.update({root:0})                      
                elif fp.find("\\W\\") > -1:
                    size = 320,240
                elif fp.find("\\M\\") > -1:
                    size = 1664,64
                elif fp.find("\\L\\") > -1:
                    size = 16,16
                elif fp.find("\\T\\") > -1:
                    size = 320,TEXT_FONT_SIZE
                else:
                    size = 64,64
                #print ppm
                #print ile
                #print size
                im = Image.open(fp).convert("RGB")
                #im.thumbnail(size, Image.ANTIALIAS)
                im = im.resize(size, Image.BILINEAR)
                im.save(ppm)
                #convert to custom 565 data stream format
                #Gen565Stream("test.ppm","test.ile")
                Gen565Stream(ppm,ile)
                #now delete the ppm file
                os.remove(ppm)                
                #print "done."
    f = open(".\\A\\V\\vdo_manifest.txt",'w')
    #f.write(json.dumps(dstruct))
    f.write(str(len(dstruct.keys())) + "\n")
    for key in dstruct.keys():
        f.write(key[1:].replace("\\","/") + "\n")
        f.write(str(dstruct[key]) + "\n")
    f.close()
    